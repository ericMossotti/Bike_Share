---
title: "Case study: Bike-sharing program in the chicago area"
author: "Eric Mossotti"
date: "05-01-2024"
bibliography: references.bib
repo: https://github.com/ericMossotti/Bike_Share
source: index.qmd
abstract-title: "Objective"
abstract: "Communicate data-driven insights to stakeholders."
description-meta: "Communicate data-driven insights to stakeholders."
code-links:
    - text: "Project Repo"
      href: repo
code-fold: true
code-copy: hover
#code-overflow: wrap
code-tools: true
code-link: true
#toc: true
#toc_float: true
#smooth-scroll: true
#fig-responsive: true
echo: true

margin-left: 15vh
margin-right: 5vh
margin-bottom: 5vh
margin-top: 5vh

#font: merriweather, futura
---

```{r, include = FALSE}

knitr::opts_chunk$set(message = FALSE, 
                      warning = FALSE)

```


:::{.btn .btn-primary}
colby's button
:::

::: {.d-flex style="gap: 5%"}
::: {.p-4 style="max-width: 70vh"}
## Import and Project Design

Data source for this data analysis, @divvyda.

Thinking ahead with reproducibility in mind, @importOrConnect should cover most use cases for tinkering and testing. I have found it helpful to reduce the need to re-download files and re-process all over again if all one needs to do is reconnect to the database that has already been written.

As a counterpart to the if-else design decision at the top of the project, I've condensed the initial download, import and cleaning steps inside of an R-script, @importProcessScript

Choosing a persistent DuckDB database filesystem (as opposed to in-memory) was intentional as I wouldn't lose the progress I've made when tinkering over multiple days. It seems just as fast as the in-memory database but also seems to reduce RAM needed in tinkering. [@whyduck]
:::

::: {.p-4 .card .bg-secondary .mb-3 .align-self-center .overflow-y-auto style="max-height: 35vh; max-width: 60vh; scrollbar-width: thin; scrollbar-color: #00cc00 #001a00"}

```{r}
#| label: importOrConnect
#| code-summary: Import or just connect
if(exists("dbconn") == FALSE && dir.exists("db") == FALSE) {
    
    # Script to keep this document less cluttered. 
    source("import_clean_initial.R")
    } else {
        # you will have to change original_nobs if you use different data
        # helps with tinkering when you want to skip the import part
        original_nobs <- as.integer(5719877)
        
        tblPath <- "db/data.db"
        
        dbconn <- DBI::dbConnect(
            duckdb::duckdb(),
            dbdir = tblPath,
            read_only = FALSE,
            check_from = FALSE
        )
    }
#    color: rgb(255, 125,10)
#  box-shadow: 8px 8px 10px #99ff99"
```

```{r}
#| label: importProcessScript
#| code-summary: Data import and initial processing script.
#| file: "import_clean_initial.R"
#| eval: false 
#| code-fold: true
```

```{r}
#| label: dbMatrix
#| eval: false

duckdb::dbListTables(dbconn) |>
    #cat(sep = "\n") |>
    as.matrix()
```
:::

:::

# hello

fijfoiwejfoiwejf

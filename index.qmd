---
title: "Bike-Sharing in the Streets of Chicago"
author: "Eric Mossotti"
date: "05-12-2024"
bibliography: references.bib
repo: https://github.com/ericMossotti/Bike_Share
source: index.qmd
abstract-title: "Objective"
abstract: "Communicate data-driven insights to stakeholders."
description-meta: "Communicate data-driven insights to stakeholders."

code-links:
    - text: "Project Repo"
      href: repo
code-fold: true
code-copy: hover
code-overflow: wrap
code-tools: true
code-link: true

toc-expand: true
toc: true
#toc_float: true
number-sections: true

smooth-scroll: true
fig-responsive: true
echo: true

#font: merriweather, futura
---

```{r, include = FALSE}

knitr::opts_chunk$set(message = FALSE, 
                      warning = FALSE)
```

------------------------------------------------------------------------

# Design and Purpose

::: {#offcanvas1 .offcanvas .offcanvas-end tabindex="-1" aria-labelledby="offcanvas" style="width: auto"}
::: offcanvas-header
::: {#offcanvasLabel .h5 .offcanvas-title}
Import Processing Code
:::

::: {.btn-close type="button" data-bs-dismiss="offcanvas" ariaLabel="Close"}
:::
:::

::: offcanvas-body
::: flex-code
```{r}
#| label: importOrConnect
#| code-summary: First, we decide whether to download and do the necessary initial processing steps or skip that if we have already done this and are just tinkering around with the project. 

if(exists("dbconn") == FALSE &&
   dir.exists("db") == FALSE) {
    # Script within if-else to simplify workflow
    source("Scripts/import_clean_initial.R")
} else {
    tblPath <- "db/data.db"
    
    dbconn <- DBI::dbConnect(
        duckdb::duckdb(),
        dbdir = tblPath,
        read_only = FALSE)
}

# Paths one might need if script doesn't execute.
tblPath <- "db/data.db"
dupelessPath <- "db/dupeless.db"
tblPath_fltrd <- "db/data_fltrd.db"
rawPath <- "db/rawData.db"

```

```{r}
#| label: importProcessScript
#| code-summary: This then would be executed if conditions were met. Usually, this would only execute if there is no db folder and associated files.
#| file: "Scripts/import_clean_initial.R"
#| eval: false 
```

```{r}
#| label: tbl-dbList
#| code-summary: It would now be helpful to verify the tables written so far.
#| tbl-cap: Database Table List

dbList <- duckdb::dbListTables(dbconn) |>
    data.frame() |>
    gt::gt() |>
    gt::tab_header(
        title = "Database Tables",
        subtitle = "List of table paths in data.db") |>
    gt::cols_label(
        "duckdb..dbListTables.dbconn." = "Table Paths"
    ) |>
    gt::tab_options(
        table.background.color = "transparent",
        table.font.color = "SeaShell",
        column_labels.hidden = TRUE,
        row.striping.background_color = "gray10",
        row.striping.include_table_body = TRUE,
        table.font.size = gt::px(13)
    )

dbList
```
:::
:::
:::

## Stakeholders

Starting off, the stakeholders can be identified as Divvy, Lyft, and the City of Chicago Department of Transportation. As such this analysis is meant to provide stakeholders with data-based guidance to better server the residents of Chicago and users of the Divvy bike sharing service. Improving air quality, promoting economic recovery, and reducing traffic congestion were among the rationale for Divvy's implementation. [@aboutdi]

## Source

The raw 2023 dataset was directly sourced from Divvy Data. [@divvyda]

## Design

Another worthy goal of this analysis is to achieve reproducibility and efficiency. To help future analyst teams move this research forward, this project tried to provide adequate code documentation and best practices with regards to clean code and modularity.

For example, it was helpful to incorporate certain design decisions to eliminate re-downloading and re-processing of data. For users conducting analysis over the course of days-months on this dataset, following initial download and processing, it is now possible to simply reconnect to the single database file which contains all of the original data including tables written throughout the course of the analysis.

The underlying code incorporates an if-else decision, which includes a source code script that handles the initial processing and establishes the database filesystem. Choosing a persistent DuckDB filesystem (as opposed to purely in-memory) seemed optimal in terms of the simplicity and cost-effectiveness of SQL database queries while retaining progress made over extended periods. [@whyduck]

# Tidying

The starting observation count was 5,719,877. Then 1,388,170 incomplete observations were then removed by the initial processing script.

:::{.d-flex .justify-content-center}
::: {.callout-note title="Click the icons such as these for code related to the sections they are found" style="width: 60%"}
::: {.btn .btn-secondary type="button" data-bs-toggle="offcanvas" data-bs-target="#offcanvas1" aria-controls="offcanvas"}
More code processing steps are available via the code icon links scattered throughout the document, such as the one below. The code summaries are given to help supplement the reader with context to help understand how and why the data is processed throughout: 
```{=html}
<i class="bi bi-code-slash" style="font-size: 1.5rem; color: cornflowerblue"></i>
```
:::
:::
:::

## Duplicates

::: {#offcanvas2 .offcanvas .offcanvas-end tabindex="-1" aria-labelledby="offcanvas" style="width: auto"}
::: offcanvas-header
::: {.h5 .offcanvas-title}
Code to Remove Duplicates
:::
::: {.btn-close type="button" data-bs-dismiss="offcanvas" ariaLabel="Close"}
:::
:::
::: offcanvas-body
::: flex-code

```{r}
#| label: originalNobs
#| code-summary: First, record original observations from the raw data.

# Need to save this count for the summary table later
original_nobs <- dplyr::tbl(dbconn, rawPath) |>
dplyr::collect() |>
nrow()

```

```{r}
#| label: duplicates_gt
#| code-summary: Create a table containing the duplicated observations.

# This is a separate table used to analyze the observations 
#  returned as not distinct (n > 1). 
#   This adds an extra column, labeled "n".
dupeTable <- dplyr::tbl(dbconn,
                        tblPath,
                        check_from = FALSE) |>
    dplyr::select(started_at:end_station_name) |>
    # Counts of unique rows added for column 'n'
    dplyr::add_count(started_at,
                     ended_at,
                     start_station_name,
                     end_station_name) |>
    # Only observations that have been duplicated 
    #  1 or more times are shown.
    dplyr::filter(n > 1) |>
    # We want to see all rows, 
    #  not just one row for each obs.
    dplyr::ungroup() |>
    dplyr::arrange(started_at) |>
    dplyr::collect()
```

```{r}
#| label: duplicateObs count
#| code-summary: Record a count of distinct duplicates and total observations.

distinctCopiesCount <- dupeTable |>
    dplyr::distinct(n) |>
    as.integer() 

duplicateObs <- length(dupeTable[[1]])
```

```{r}
#| label: undupedTable
#| code-summary: Create a table of the now unduplicated observations seen earlier.

# The issue is, we need to get rid of not all of these rows, but just the extra duplicate observations.

# If there were 2 rows of duplicates, one would want to end up with 1 row after removing the extras.
undupedTable <- 
dupeTable |>
dplyr::distinct(started_at, 
start_station_name, 
ended_at, 
end_station_name)
```

```{r}
#| label: incorrect distinct obs count
#| code-summary: Record a count of the incorrect observations.

# Run an incorrect count on how many rows or observations there are in the dataset.
count_incorrectDists <- dplyr::tbl(dbconn,
                                   tblPath,
                                   check_from = FALSE) |>
    dplyr::distinct(dplyr::pick("ride_id")) |>
    dplyr::count(name = "Incorrect Distinct Observations") |>
    dplyr::collect() |>
    as.integer()
```

```{r}
#| label: count_correctDists count
#| code-summary: Record a count of the correct observations.

# For the correct count of obs
count_correctDists <- dplyr::tbl(dbconn,
                                 tblPath,
                                 check_from = FALSE) |>
    dplyr::distinct(
        dplyr::pick(
            "started_at",
            "start_station_name",
            "ended_at",
            "end_station_name")) |>
    dplyr::count() |>
    dplyr::collect() |>
    as.integer()
```

```{r}
#| label: 'overwrite file with correct obs'
#| code-summary: Lastly, write the unduplicated data to the database.

dupelessPath <- "db/dupeless.db"
 
dplyr::tbl(dbconn,
           tblPath,
           check_from = FALSE) |>
    dplyr::select(ride_id:trip_time) |>
    dplyr::distinct(started_at,
                    start_station_name,
                    ended_at,
                    end_station_name,
                    .keep_all = TRUE) |>
    dplyr::arrange(started_at) |>
    dplyr::collect() |>
    duckdb::dbWriteTable(conn = dbconn,
                         name = dupelessPath,
                         overwrite = TRUE)
```

:::
:::
:::

::: {.p-3}
A question arises: How does one check the data for duplicates? That is what this section covers, alongside how to only remove what is needed. Care is needed because it might not necessarily be the case that each observation, or *obs* for short, is unique because a column contains all unique values.

All of the values in the **ride_id** column were found to be unique. However, not all of the obs, or rows, were found to be truly unique. Other columns such as **start_time**, **end_time**, **start_station**, and **end_station** were used to verify if an obs was distinct. These would have more granular information, down to the second, a given starting time, ending time, and location. It was assumed that obs having the same starting and ending date-time and station despite having two different rider IDs was a mistake.
:::

::: {.tableScroller .p-3}
```{r}
#| label: tbl-duplicates
#| tbl-cap: Duplicates Table


gtDupes <- dupeTable |>
dplyr::group_by(started_at) |>
gt::gt(
rowname_col = "row",
groupname_col = "started_at",
row_group_as_column = TRUE
) |>
gt::tab_style(
style = list(
gt::cell_text(weight = "bold", align = "center"),
gt::cell_borders(sides = c("bottom"))
),
locations = gt::cells_column_labels(gt::everything())
) |>
gt::tab_style(
style = list(
gt::cell_borders(sides = c("left", "right"), color = "transparent"),
gt::cell_text(align = "center", v_align = "middle")
),
locations = gt::cells_body(gt::everything())
) |>
gt::data_color(
columns = start_station_name,
target_columns = gt::everything(),
method = "auto",
palette = "basetheme::brutal"
) |>
gt::tab_header(title = "A view of duplicated observations", subtitle = "Grouping follows the starting date-time value") |>
gt::tab_options(
heading.title.font.weight = "bolder",
heading.subtitle.font.weight = "lighter",
heading.align = "center",
table.background.color = "transparent",
table.font.color = "SeaShell",
table.font.size = gt::pct(75),
)


gtDupes
```
:::

:::{.p-3}
Although, it is actually unknown how that error would happen. It could have been assumed that one person checked out multiple bikes at once. In that instance, each bike would be assigned a unique **ride_id**. That, however, has only happened **18** times over a year. Since it is only one copy every time, red flags were raised. Perhaps trips could be grouped where one person pays for a other riders? If that were the case, then why is there always one duplicate?

In @tbl-duplicates, duplicate observations were listed and grouped by color. Contrast this with @tbl-unduplicated, which has removed the extra copy of the observation while preserving the observation itself. Of the duplicates, each had one extra copy. It was noted that the number of rows in the duplicates table is 36. Each duplicated observation has one duplicate, where **n** is always the value 2. So the expected removed obs was 18. A complication involved how to remove not all obs but just one extra duplicate observation from each.
:::

::: {.p-3 .tableScroller}
```{r}
#| label: tbl-unduplicated
#| tbl-cap: Un-duplicated Table
#| echo: false

gt_undupes <- undupedTable |>
dplyr::collect() |>
dplyr::group_by(started_at) |>
gt::gt(
rowname_col = "row",
groupname_col = "started_at",
row_group_as_column = TRUE
) |>
gt::fmt_number(decimals = 0) |>

gt::tab_style(
style = list(
gt::cell_text(weight = "bold", align = "center"),
gt::cell_borders(sides = c("bottom"))
),
locations = gt::cells_column_labels(gt::everything())
) |>
gt::tab_style(
style = list(
gt::cell_borders(sides = c("left", "right")),
gt::cell_text(align = "center", v_align = "middle")
),
locations = gt::cells_body(gt::everything())
) |>
gt::data_color(
columns = start_station_name,
target_columns = gt::everything(),
method = "auto",
palette = "basetheme::brutal"
) |>
gt::tab_header(title = "After duplicates were removed", subtitle = "Same grouping") |>
gt::tab_options(
heading.title.font.weight = "bolder",
heading.subtitle.font.weight = "lighter",
heading.align = "center",
table.background.color = "transparent",
table.font.color = "SeaShell",
table.font.size = gt::pct(75)
)

gt_undupes
```
:::

:::{.p-3}
The count of distinct n-values for the un-duplicated table was 18. Then a count of observations in the dataset were recorded. The incorrect number of obs was 4,331,707. The correct obs after removing duplicated obs was 4,331,689. In short, 18 additional obs were removed.  @tbl-observationHistory
:::
:::{.p-3}
```{r}
#| label: tbl-observationHistory
#| tbl-cap: Observation Processing History

# To see the history of obs in our dataset.
summaryProcessTable <- tidyr::tribble(
~ "Observations",
~ "Counts",
"Original   ",
original_nobs,
"Processed   ",
count_incorrectDists,
"Duplicates   ",
(count_incorrectDists - count_correctDists),
"Total Corrected   ",
count_correctDists
) |>
gt::gt(rownames_to_stub = FALSE) |>
gt::tab_header(title = "Tallying Observations") |>
gt::tab_footnote(
footnote = gt::md("Row counts throughout the cleaning steps."),
locations = gt::cells_column_labels(columns = Counts)
) |>
gt::tab_style(
style = list(
gt::cell_borders(sides = "bottom"),
gt::cell_text(
align = "left",
stretch = "semi-expanded",
whitespace = "break-spaces"
)
),
locations = gt::cells_body(gt::everything())
) |>
gt::tab_style(
gt::cell_text(
align = "center",
stretch = "semi-expanded",
whitespace = "break-spaces"
),
locations = list(
gt::cells_title(groups = c("title", "subtitle")),
gt::cells_column_labels(gt::everything())
)
) |>
gt::fmt_number(decimals = 0) |>
gt::tab_options(
quarto.use_bootstrap = TRUE,
column_labels.font.weight = "bold",
table.background.color = "transparent",
table.font.color = "SeaShell",
row.striping.background_color = "gray10",
row.striping.include_table_body = TRUE
)

summaryProcessTable
```
:::

:::{.d-flex .justify-content-center}
::: {.btn .btn-secondary type="button" data-bs-toggle="offcanvas" data-bs-target="#offcanvas2" aria-controls="offcanvas"}
```{=html}
<i class="bi bi-code-slash" style="font-size: 1.5rem; color: cornflowerblue"></i>
```
:::
:::

## Outliers

Observations that were deemed erroneous or not useful for identifying trends in how the service is utilized by members and casual users were filtered out. It is good practice to keep note of these errors as they might explain some differences in how members and casual use the service.

It was determined that trips with negative minutes were errors. Trips less than 1 minute but greater than 0 were noted, but removed, as they might skew the statistics we derive from this data too much later on. The underlying reason for low trip times could be from people just wanting to try it out briefly before committing or quickly realized they did not like it. There were observations that did not make much sense, but most of the data was retained.

As in the first part, an **if-else** decision was chosen because it makes testing easier. An external database filtering script was chosen to shorten the code needed inside the main Quarto document itself. The data from which the rest of the tables are based on are used for the rest of the analysis.

::: {.d-flex .justify-content-center max-width="auto"}
::: {.callout-note title="Filter the database" style="min-width: auto; max-width: auto"}
::: {#filterScript .codeDisplayer}
```{r}
#| label: filterScript
#| code-summary: This would execute if the if-else conditions were met to filter the db/data.db database table
#| file: "Scripts/filterDatabase.R"
#| eval: false
```
:::
:::
:::

::: {.d-flex .justify-content-center}
::: {.btn .btn-secondary type="button" data-bs-toggle="offcanvas" data-bs-target="#offcanvas33" aria-controls="offcanvas"}
```{=html}
<i class="bi bi-code-slash" style="font-size: .75em; color: cornflowerblue;"></i>
```
:::
:::

::: {#offcanvas33 .offcanvas .offcanvas-start tabindex="-1" aria-labelledby="offcanvas" style="width: auto"}
::: offcanvas-header
::: {.h5 .offcanvas-title}
Filter Database
:::

::: {.btn-close type="button" data-bs-dismiss="offcanvas" ariaLabel="Close"}
:::
:::

::: offcanvas-body
::: flex-code
```{r}
#| label: filtering db
#| code-summary: First, if you happen to be re-using this code - this is so you do not have to re-download or re-filter after making further adjustments.

tblPath <- "db/data.db"
dupelessPath <- "db/dupeless.db"
tblPath_fltrd <- "db/data_fltrd.db"

if (exists("dbconn") == FALSE && dir.exists("db") == TRUE) {
    dbconn <- DBI::dbConnect(
        duckdb::duckdb(),
        dbdir = tblPath,
        read_only = FALSE)
}

if (duckdb::dbExistsTable(dbconn,
                          "tblPath_fltrd") == FALSE) {
    source("Scripts/filterDatabase.R")
    filterDatabase()
}
```
:::
:::
:::

# Exploratory Analysis

::: {.column-body .mb-2}
## Contingency Tables {#sec-writeFreqs}

The rationale for contingency tables here is to gain quick insights into the data. It is taking a methodical approach that, while simple, can create a crucial pathway towards understanding the bigger picture. Many of these tables are used in the tabset section, @sec-freqAnalysis. Some of the tables in the following section had to be further customized.
:::

::: {.d-flex .justify-content-center .mb-3}
::: {.btn .btn-secondary type="button" data-bs-toggle="offcanvas" data-bs-target="#offcanvas10" aria-controls="offcanvas"}
```{=html}
<i class="bi bi-code-slash" style="font-size: .75em; color: cornflowerblue;"></i>
```
:::
:::

::: {#offcanvas10 .offcanvas .offcanvas-end tabindex="-1" aria-labelledby="offcanvas" style="width: auto"}
::: offcanvas-header
::: {.h5 .offcanvas-title}
Frequency Tables (other code)
:::

::: {.btn-close type="button" data-bs-dismiss="offcanvas" ariaLabel="Close"}
:::
:::

::: offcanvas-body
::: flex-code
```{r}
#| label: frequencyWrites_totals
#| code-summary: First, write the totals frequency tables to database.

# For the membership frequency
dplyr::tbl(dbconn,
           tblPath_fltrd,
           check_from = FALSE) |>
    dplyr::select(member_casual) |>
    dplyr::group_by(member_casual) |>
    dplyr::summarize(n = dplyr::n()) |>
    dplyr::collect() |>
    duckdb::dbWriteTable(conn = dbconn,
                         name = "db/freq_member.db",
                         overwrite = TRUE,
                         check_from = FALSE)

# For the rideable types.
dplyr::tbl(dbconn,
           tblPath_fltrd,
           check_from = FALSE) |>
    dplyr::select(rideable_type) |>
    dplyr::group_by(rideable_type) |>
    dplyr::summarize(n = dplyr::n()) |>
    dplyr::collect() |>
    duckdb::dbWriteTable(conn = dbconn,
                         name = "db/freq_rTypes.db",
                         overwrite = TRUE,
                         check_from = FALSE)

# For the miles
dplyr::tbl(dbconn,
           tblPath_fltrd,
           check_from = FALSE) |>
    dplyr::select(miles) |>
    dplyr::collect() |>
    dplyr::mutate(miles = dplyr::case_when(
        miles >= 1 ~ round(miles,
                           digits = 0),
        miles < 1 ~ round(signif(miles, 3),
                          digits = 1)
    )) |>
    dplyr::group_by(miles) |>
    dplyr::summarize(n = dplyr::n()) |>
    dplyr::arrange(miles) |>
    duckdb::dbWriteTable(
        conn = dbconn,
        name = "db/freq_miles.db",
        check_from = FALSE,
        overwrite = TRUE)

# For the mph
dplyr::tbl(dbconn,
           tblPath_fltrd,
           check_from = FALSE) |>
    dplyr::select(mph) |>
    dplyr::mutate(mph = round(mph, digits = 0)) |>
    dplyr::group_by(mph) |>
    dplyr::summarize(n = dplyr::n()) |>
    dplyr::collect() |>
    dplyr::arrange(mph) |>
    duckdb::dbWriteTable(conn = dbconn,
                         name = "db/freq_mph.db",
                         check_from = FALSE,
                         overwrite = TRUE)

# For the week days
dplyr::tbl(dbconn,
           tblPath_fltrd,
           check_from = FALSE) |>
    dplyr::select(started_at) |>
    dplyr::mutate(wkday = lubridate::wday(started_at)) |>
    dplyr::group_by(wkday) |>
    dplyr::summarize(n = dplyr::n()) |>
    dplyr::arrange(wkday) |>
    dplyr::collect() |>
    dplyr::mutate(wkday = c("Sun",
                            "Mon",
                            "Tue",
                            "Wed",
                            "Thu",
                            "Fri",
                            "Sat"),
                  wkday = forcats::as_factor(wkday),
                  wkday = forcats::fct_inorder(wkday)) |>
    duckdb::dbWriteTable(conn = dbconn,
                         name = "db/freq_wkDay.db",
                         check_from = FALSE,
                         overwrite = TRUE)

# For the months.
dplyr::tbl(dbconn,
           tblPath_fltrd,
           check_from = FALSE) |>
    dplyr::select(started_at) |>
    dplyr::mutate(months = lubridate::month(started_at,
                                            label = FALSE,
                                            abbr = TRUE
                                            )) |>
    dplyr::group_by(months) |>
    dplyr::summarize(n = dplyr::n()) |>
    dplyr::collect() |>
    dplyr::arrange(months) |>
    dplyr::mutate(months = c(month.abb),
                  months = forcats::as_factor(months),
                  months = forcats::fct_inorder(months)) |>
    duckdb::dbWriteTable(conn = dbconn,
                         name = "db/freq_month.db",
                         check_from = FALSE,
                         overwrite = TRUE)

# For the trip times.
dplyr::tbl(dbconn,
           tblPath_fltrd) |>
    dplyr::mutate(trip_time = round(trip_time,
                                    digits = 0)) |>
    dplyr::group_by(trip_time) |>
    dplyr::summarize(n = dplyr::n()) |>
    dplyr::arrange(trip_time) |>
    dplyr::collect() |>
    duckdb::dbWriteTable(conn = dbconn,
                         name = "db/freq_tripTime.db",
                         check_from = FALSE,
                         overwrite = TRUE)

# For the start station names
dplyr::tbl(dbconn,
           tblPath_fltrd) |>
    dplyr::select(start_station_name) |>
    dplyr::group_by(start_station_name) |>
    dplyr::summarize(n = dplyr::n()) |>
    dplyr::arrange(start_station_name) |>
    dplyr::collect() |>
    duckdb::dbWriteTable(conn = dbconn,
                         name = "db/freq_startNames.db",
                         check_from = FALSE,
                         overwrite = TRUE)


# For the station name pairs.
dplyr::tbl(dbconn,
           tblPath_fltrd) |>
    dplyr::select(start_station_name,
                  end_station_name) |>
    dplyr::group_by(start_station_name,
                    end_station_name) |>
    dplyr::summarize(n = dplyr::n()) |>
    dplyr::arrange(start_station_name) |>
    dplyr::collect() |>
    duckdb::dbWriteTable(conn = dbconn,
                         name = "db/freq_pairStations.db",
                         check_from = FALSE,
                         overwrite = TRUE)

# for the hours
dplyr::tbl(dbconn,
           tblPath_fltrd,
           check_from = FALSE) |>
    dplyr::select(started_at) |>
    dplyr::mutate("hour" = lubridate::hour(started_at)) |>
    dplyr::group_by(hour) |>
    dplyr::summarise("Total_Riders" = dplyr::n()) |> #or count?
    dplyr::arrange(hour) |>
    dplyr::collect() |>
    dplyr::mutate("hour" = hms::hms(hours = hour),
                  "hour" = format(strptime(hour, format = "%H"), "%r"),
                  "index" = seq(1:24)) |>
    duckdb::dbWriteTable(conn = dbconn,
                         name = "db/freq_hours.db",
                         check_from = FALSE,
                         overwrite = TRUE)

```

```{r}
#| label: frequencyWrites_comparisons
#| code-summary: Then, write all of the frequency comparison tables to the database.

# For the rideable type comparison
dplyr::tbl(dbconn,
           tblPath_fltrd,
           check_from = FALSE) |>
    dplyr::select(member_casual,
                  rideable_type) |>
    dplyr::group_by(rideable_type,
                    member_casual) |>
    dplyr::summarize(n = dplyr::n()) |>
    dplyr::collect() |>
    duckdb::dbWriteTable(conn = dbconn,
                         name = "db/freqCompare_rType.db",
                         overwrite = TRUE,
                         check_from = FALSE)

# For the miles comparison
dplyr::tbl(dbconn,
           tblPath_fltrd,
           check_from = FALSE) |>
    dplyr::select(member_casual,
                  miles) |>
    dplyr::collect() |>
    dplyr::mutate(miles = dplyr::case_when(
        miles >= 1 ~ round(miles,
                           digits = 0),
        miles < 1 ~ round(signif(miles, 3),
                          digits = 1)
    )) |>
    dplyr::group_by(miles,
                    member_casual) |>
    dplyr::summarize(n = dplyr::n()) |>
    dplyr::arrange(miles) |>
    duckdb::dbWriteTable(
        conn = dbconn,
        name = "db/freqCompare_miles.db",
        check_from = FALSE,
        overwrite = TRUE)

# For the mph comparison
dplyr::tbl(dbconn,
           tblPath_fltrd,
           check_from = FALSE) |>
    dplyr::select(mph,
                  member_casual) |>
    dplyr::mutate(mph = round(mph, digits = 0)) |>
    dplyr::group_by(member_casual,
                    mph) |>
    dplyr::summarize(n = dplyr::n()) |>
    dplyr::collect() |>
    dplyr::arrange(mph) |>
    duckdb::dbWriteTable(conn = dbconn,
                         name = "db/freqCompare_mph.db",
                         check_from = FALSE,
                         overwrite = TRUE)

# For the week days  comparison
dplyr::tbl(dbconn,
           tblPath_fltrd,
           check_from = FALSE) |>
    dplyr::select(member_casual,
                  started_at) |>
    dplyr::mutate(wkday = lubridate::wday(started_at)) |>
    dplyr::group_by(member_casual,
                    wkday) |>
    dplyr::summarize(n = dplyr::n()) |>
    dplyr::arrange(wkday) |>
    dplyr::collect() |>
    dplyr::mutate(wkday = c("Sun",
                            "Mon",
                            "Tue",
                            "Wed",
                            "Thu",
                            "Fri",
                            "Sat"),
                  wkday = forcats::as_factor(wkday),
                  wkday = forcats::fct_inorder(wkday)) |>
    duckdb::dbWriteTable(conn = dbconn,
                         name = "db/freqCompare_wkDay.db",
                         check_from = FALSE,
                         overwrite = TRUE)

# For the months comparison
dplyr::tbl(dbconn,
           tblPath_fltrd,
           check_from = FALSE) |>
    dplyr::select(member_casual,
                  started_at) |>
    dplyr::mutate(months = lubridate::month(started_at,
                                            label = FALSE,
                                            abbr = TRUE)) |>
    dplyr::group_by(member_casual,
                    months) |>
    dplyr::summarize(n = dplyr::n()) |>
    dplyr::collect() |>
    dplyr::arrange(months) |>
    dplyr::mutate(months = c(month.abb),
                  months = forcats::as_factor(months),
                  months = forcats::fct_inorder(months)) |>
    duckdb::dbWriteTable(conn = dbconn,
                         name = "db/freqCompare_month.db",
                         check_from = FALSE,
                         overwrite = TRUE)


# For the trip times comparison
dplyr::tbl(dbconn,
           tblPath_fltrd) |>
    dplyr::select(member_casual,
                  trip_time) |>
    dplyr::mutate(trip_time = round(trip_time,
                                    digits = 0)) |>
    dplyr::group_by(member_casual,
                    trip_time) |>
    dplyr::summarize(n = dplyr::n()) |>
    dplyr::arrange(trip_time) |>
    dplyr::collect() |>
    duckdb::dbWriteTable(conn = dbconn,
                         name = "db/freqCompare_tripTime.db",
                         check_from = FALSE,
                         overwrite = TRUE)

# For the start station names comparison
dplyr::tbl(dbconn,
           tblPath_fltrd) |>
    dplyr::select(member_casual,
                  start_station_name) |>
    dplyr::group_by(member_casual,
                    start_station_name) |>
    dplyr::summarize(n = dplyr::n()) |>
    dplyr::arrange(start_station_name) |>
    dplyr::collect() |>
    duckdb::dbWriteTable(conn = dbconn,
                         name = "db/freqCompare_startNames.db",
                         check_from = FALSE,
                         overwrite = TRUE)

# For the station name pairs comparison
dplyr::tbl(dbconn,
           tblPath_fltrd) |>
    dplyr::select(member_casual,
                  start_station_name,
                  end_station_name) |>
    dplyr::group_by(start_station_name,
                    end_station_name,
                    member_casual) |>
    dplyr::summarize(n = dplyr::n()) |>
    dplyr::arrange(start_station_name,
                   end_station_name) |>
    dplyr::collect() |>
    duckdb::dbWriteTable(conn = dbconn,
                         name = "db/freqCompare_pairStations.db",
                         check_from = FALSE,
                         overwrite = TRUE)

dplyr::tbl(dbconn,
           tblPath_fltrd,
           check_from = FALSE) |>
    dplyr::select(started_at, member_casual) |>
    dplyr::mutate("hour" = lubridate::hour(started_at)) |>
    dplyr::group_by(member_casual, hour) |>
    dplyr::summarise("Total_Riders" = dplyr::n()) |> #or count?
    dplyr::arrange(hour, member_casual) |>
    dplyr::collect() |>
    dplyr::mutate("hour" = hms::hms(hours = hour),
                  "hour" = format(strptime(hour, format = "%H"), "%r"),
                  "index" = seq(1:24)) |>
    duckdb::dbWriteTable(conn = dbconn,
                         name = "db/freqCompare_hours.db",
                         check_from = FALSE,
                         overwrite = TRUE)
```
:::
:::
:::

## Table Analysis {#sec-freqAnalysis}

::: column-screen
::: {.d-flex .justify-content-center}

::: {.panel-tabset .shadow-sm}

## Membership

::: article
::: section
::: {.d-flex .justify-content-around .align-content-stretch}
::: {.p-3 .align-self-center .align-content-stretch .auto-fit}
### Overall Member to Casual Count 
:::

::: divBox
:::

::: {.p-3 .align-self-center}
@tbl-memberTotals gives the total count of trips taken by members and casuals. The rest of the tabs in this section will give total counts along with group counts by membership status.
:::
:::
:::

------------------------------------------------------------------------

::: {.d-flex .align-content-stretch}
::: p-3
```{r}
#| label: tbl-memberTotals
#| tbl-cap: Total Member Frequency


dplyr::tbl(dbconn, "db/freq_member.db") |>
gt::gt() |>
gt::tab_header(title = "Subscriber Frequency") |>
gt::fmt_number(decimals = 0) |>
gt::cols_label(member_casual = "Membership", n = "Trips") |>
gt::tab_options(
table.background.color = 'transparent',
table.font.color = "SeaShell",
table_body.vlines.color = "gray20",
table_body.hlines.color = "gray20",
column_labels.hidden = FALSE)

```
:::

::: p-3
```{r}
#| label: fig-totalmemberFrequency
#| fig-cap: Total Member Frequency

dplyr::tbl(dbconn, "db/freq_member.db") |>
dplyr::collect() |>
ggplot2::ggplot(mapping = ggplot2::aes(x = member_casual, y = n, fill = n)) +
ggplot2::geom_col(show.legend = FALSE) +
ggplot2::labs(title = "Membership Frequency", x = "Membership", y = "Trips") +
ggplot2::scale_fill_distiller(palette = "YlOrRd") +
ggplot2::theme(
panel.background = ggplot2::element_rect(fill = "#222222", color = NA),
plot.background = ggplot2::element_rect(fill = "#222222", color = NA),
text = ggplot2::element_text(color = "seashell"),
panel.grid = ggplot2::element_blank(),
axis.title.x = ggplot2::element_text(margin = grid::unit(c(5, 5, 5, 5), "mm")),
axis.title.y = ggplot2::element_text(margin = grid::unit(c(5, 5, 5, 5), "mm")),
axis.text.x = ggplot2::element_text(color = "Snow", margin = grid::unit(c(1, 1, 1, 1), "mm")),
axis.text.y = ggplot2::element_text(color = "Snow", margin = grid::unit(c(2, 2, 2, 2), "mm")),
axis.ticks = ggplot2::element_line(color = "LavenderBlush"),
axis.ticks.y = ggplot2::element_blank(),
panel.grid.major.y = ggplot2::element_line(color = "grey30"))

```
:::
:::
:::

## Cycle Types

::: article
::: section
::: {.d-flex .align-content-stretch}
::: {.p-3 .align-self-center}
-   [Totals Summary](#total_types_freq)
-   [Membership Summary](#group_types_freq)
-   [Test Association](#sec-chiTypes)
:::

::: divBox
:::

::: {.p-1 .align-self-center}
In @tbl-ctypeTotals and @fig-ctypeTotals, the total trips taken on conventional bicycles and electric bicycles are compared. Clearly, electric bicycles are not used as much as conventional.

Moving to @tbl-ctypeCompare and @fig-ctypeCompare, the frequency of trips taken is split into groups of membership status. There is a large disparity not only between the scale of trips taken between annual subscribers and casual users, but also within the the group of subscribers themselves. While there is a small difference between trips taken by casual members on conventional compared to electric, that said difference is more pronounced in the annual subscriber group.

With $p < 0.05$, there appears to be a strong association between members and casuals with regards to the type of bicycles people are likely to ride. @tbl-chiTypes
:::
:::
:::

------------------------------------------------------------------------

### Totals Summary {#total_types_freq}

::: {.d-flex .align-content-stretch}
::: p-3
```{r}
#| label: tbl-ctypeTotals
#| tbl-cap: Cycle Type Total Frequency

dplyr::tbl(dbconn, "db/freq_rTypes.db") |>
gt::gt() |>
gt::tab_header(title = "Bicycle Type") |>
gt::fmt_number(decimals = 0) |>
gt::cols_label(n = "Trips", rideable_type = "Bicycle Type") |>
gt::tab_options(
table.background.color = 'transparent',
table.font.color = "SeaShell",
table_body.vlines.color = "gray20",
table_body.hlines.color = "gray20",
column_labels.hidden = FALSE)

```
:::

::: p-3
```{r}
#| label: fig-ctypeTotals
#| fig-cap: Cycle Type Total Frequency 

dplyr::tbl(dbconn, "db/freq_rTypes.db") |>
dplyr::collect() |>
ggplot2::ggplot(mapping = ggplot2::aes(x = rideable_type, y = n, fill = n)) +
ggplot2::geom_col(show.legend = FALSE) +
ggplot2::scale_fill_distiller(palette = "YlOrRd") +
ggplot2::labs(title = "Cycle Type Frequency", x = "Bicycle Type", y = "Trips") +
ggplot2::theme(
panel.background = ggplot2::element_rect(fill = "#222222", color = NA),
plot.background = ggplot2::element_rect(fill = "#222222", color = NA),
text = ggplot2::element_text(color = "seashell"),
panel.grid = ggplot2::element_blank(),
axis.title.x = ggplot2::element_text(margin = grid::unit(c(5, 5, 5, 5), "mm")),
axis.title.y = ggplot2::element_text(margin = grid::unit(c(5, 5, 5, 5), "mm")),
axis.text.x = ggplot2::element_text(color = "Snow", margin = grid::unit(c(1, 1, 1, 1), "mm")),
axis.text.y = ggplot2::element_text(color = "Snow", margin = grid::unit(c(2, 2, 2, 2), "mm")),
axis.ticks = ggplot2::element_line(color = "LavenderBlush"),
axis.ticks.y = ggplot2::element_blank(),
panel.grid.major.y = ggplot2::element_line(color = "grey30"))
```
:::
:::

------------------------------------------------------------------------

### Membership Summary {#group_types_freq}

::: {.d-flex .align-content-stretch}
::: p-3
```{r}
#| label: tbl-ctypeCompare
#| tbl-cap: Cycle Type Group Frequency


dplyr::tbl(dbconn, "db/freqCompare_rType.db") |>
gt::gt(groupname_col = "rideable_type", row_group_as_column = TRUE) |>
gt::tab_header(title = "Bicycle Type to Membership") |>
gt::fmt_number(decimals = 0) |>
gt::cols_label(n = "Trips", member_casual = "Membersip") |>
gt::tab_options(
table.background.color = 'transparent',
table.font.color = "SeaShell",
table_body.vlines.color = "gray20",
table_body.hlines.color = "gray20",
column_labels.hidden = FALSE)


```
:::

::: p-3
```{r}
#| label: fig-ctypeCompare
#| fig-cap: Cycle Type Group Frequency

dplyr::tbl(dbconn, "db/freqCompare_rType.db") |>
ggplot2::ggplot(mapping = ggplot2::aes(x = rideable_type, y = n, fill = member_casual)) +
ggplot2::geom_col(show.legend = TRUE, position = "dodge") +
ggplot2::scale_fill_brewer(palette = "Paired", name = "Subscriber Status") +
ggplot2::labs(title = "Cycle Type to Membership Frequency", x = "Type", y = "Trips") +
ggplot2::theme(
panel.background = ggplot2::element_rect(fill = "#222222", color = NA),
plot.background = ggplot2::element_rect(fill = "#222222", color = NA),
text = ggplot2::element_text(color = "seashell"),
panel.grid = ggplot2::element_blank(),
axis.title.x = ggplot2::element_text(margin = grid::unit(c(5, 5, 5, 5), "mm")),
axis.title.y = ggplot2::element_text(margin = grid::unit(c(5, 5, 5, 5), "mm")),
axis.text.x = ggplot2::element_text(color = "Snow", margin = grid::unit(c(1, 1, 1, 1), "mm")),
axis.text.y = ggplot2::element_text(color = "Snow", margin = grid::unit(c(2, 2, 2, 2), "mm")),
axis.ticks = ggplot2::element_line(color = "LavenderBlush"),
axis.ticks.y = ggplot2::element_blank(),
panel.grid.major.y = ggplot2::element_line(color = "grey30"),
legend.background = ggplot2::element_rect(fill = "#222222"))

```
:::
:::

------------------------------------------------------------------------

### Testing the association between membership and bicycle type {#sec-chiTypes}

```{r}
#| label: tbl-chiTypes

dplyr::tbl(dbconn, tblPath_fltrd) |>
dplyr::select(rideable_type, member_casual) |>
dplyr::collect() |>
gtsummary::tbl_summary(by = member_casual, label = list(rideable_type = "Bicycle Type", member_casual = "Membership")) |>
gtsummary::add_p() |>
gtsummary::as_gt() |>
gt::tab_options(
table.background.color = 'transparent',
table.font.color = "SeaShell",
table_body.vlines.color = "gray20",
table_body.hlines.color = "gray20")

```
:::

## Month

::: article
::: section
::: {.d-flex .align-content-stretch}
::: {.p-3 .align-self-center}
-   [Totals Summary](#total_month_freq)
-   [Membership Summary](#group_month_freq)
-   [Test Association](#sec-monthChi)
:::

::: divBox
:::

::: {.p-1 .align-self-center}
Looking at @tbl-monthTotals and @fig-monthTotals, the warmer months appear to coincide with higher trip frequency, in total.

In @tbl-monthCompare and @fig-monthCompare, trip frequency in both groups are impacted by the seasons. Although, it would appear that trip frequency of subscribers fluctuates less than for casuals. The disparity in frequency change is more apparent in the comparison of winter to summer months between member groups.

Given $p < 0.05$, it is likely that membership status is associated with a given member's or non-member's use of the service during a particular month or season. @tbl-chiMonths
:::
:::
:::

------------------------------------------------------------------------

### Totals Summary {#total_month_freq}

::: d-flex
::: p-3
```{r}
#| label: tbl-monthTotals
#| tbl-cap: Month Total Frequency

dplyr::tbl(dbconn, "db/freq_month.db") |>
gt::gt() |>
gt::tab_header(title = "Month") |>
gt::fmt_number(decimals = 0) |>
gt::cols_label(months = "Month", n = "Trips") |>
gt::tab_options(
table.background.color = 'transparent',
table.font.color = "SeaShell",
table_body.vlines.color = "gray20",
table_body.hlines.color = "gray20",
column_labels.hidden = FALSE)
```
:::

::: p-3
```{r}
#| label: fig-monthTotals
#| fig-cap: Month Total Frequency


dplyr::tbl(dbconn, "db/freq_month.db") |>
dplyr::collect() |>
ggplot2::ggplot(mapping = ggplot2::aes(x = months, y = n, fill = n)) +
ggplot2::geom_col(show.legend = FALSE) +
ggplot2::labs(title = "Month", x = "Month", y = "Trips") +
ggplot2::scale_fill_distiller(palette = "YlOrRd") +
ggplot2::theme(
panel.background = ggplot2::element_rect(fill = "#222222", color = NA),
plot.background = ggplot2::element_rect(fill = "#222222", color = NA),
text = ggplot2::element_text(color = "seashell"),
panel.grid = ggplot2::element_blank(),
axis.title.x = ggplot2::element_text(margin = grid::unit(c(5, 5, 5, 5), "mm")),
axis.title.y = ggplot2::element_text(margin = grid::unit(c(5, 5, 5, 5), "mm")),
axis.text.x = ggplot2::element_text(color = "Snow", margin = grid::unit(c(1, 1, 1, 1), "mm")),
axis.text.y = ggplot2::element_text(color = "Snow", margin = grid::unit(c(2, 2, 2, 2), "mm")),
axis.ticks = ggplot2::element_line(color = "LavenderBlush"),
axis.ticks.y = ggplot2::element_blank(),
panel.grid.major.y = ggplot2::element_line(color = "grey30"))

```
:::
:::

------------------------------------------------------------------------

### Membership Summary {#group_month_frequency}

::: d-flex
::: {.p-3 .tableScroller}
```{r}
#| label: tbl-monthCompare
#| tbl-cap: Month Group Frequency


dplyr::tbl(dbconn, "db/freqCompare_month.db") |>
gt::gt(groupname_col = "months", row_group_as_column = TRUE) |>
gt::tab_header(title = "Month to Membership") |>
gt::fmt_number(decimals = 0) |>
gt::cols_label(months = "Month", member_casual = "Membership", n = "Trips") |>
gt::tab_options(
table.background.color = 'transparent',
table.font.color = "SeaShell",
table_body.vlines.color = "gray20",
table_body.hlines.color = "gray20",
column_labels.hidden = FALSE
)

```
:::

::: ml-5
```{r}
#| label: fig-monthCompare
#| fig-cap: Month Group Frequency

dplyr::tbl(dbconn, "db/freqCompare_month.db") |>
dplyr::collect() |>
ggplot2::ggplot(mapping = ggplot2::aes(x = months, y = n, fill = n)) +
ggplot2::geom_col(show.legend = TRUE) +
ggplot2::facet_grid(rows = "member_casual") +
ggplot2::scale_fill_distiller(palette = "YlGnBu") +
ggplot2::labs(title = "Month to Membership", x = "Month", y = "Trips") +
ggplot2::theme(
panel.background = ggplot2::element_rect(fill = "#222222", color = NA),
plot.background = ggplot2::element_rect(fill = "#222222", color = NA),
text = ggplot2::element_text(color = "seashell"),
panel.grid = ggplot2::element_blank(),
axis.title.x = ggplot2::element_text(margin = grid::unit(c(5, 5, 5, 5), "mm")),
axis.title.y = ggplot2::element_text(margin = grid::unit(c(5, 5, 5, 5), "mm")),
axis.text.x = ggplot2::element_text(color = "Snow", margin = grid::unit(c(1, 1, 1, 1), "mm")),
axis.text.y = ggplot2::element_text(color = "Snow", margin = grid::unit(c(2, 2, 2, 2), "mm")),
axis.ticks = ggplot2::element_line(color = "LavenderBlush"),
axis.ticks.y = ggplot2::element_blank(),
panel.grid.major.y = ggplot2::element_line(color = "grey30"),
legend.background = ggplot2::element_rect(fill = "#222222")
)

```
:::
:::

------------------------------------------------------------------------

### Testing the association between membership and month {#sec-monthChi}

```{r}
#| label: tbl-chiMonths

# For finding chi-square p-value in a nicely formatted table
dplyr::tbl(dbconn, tblPath_fltrd) |>
dplyr::select(member_casual, started_at) |>
dplyr::mutate(months = lubridate::month(started_at, label = TRUE, abbr = TRUE)) |>
dplyr::collect() |>
dplyr::mutate(
months = forcats::as_factor(months), 
months = forcats::fct_inorder(months)) |>
gtsummary::tbl_summary(
by = member_casual, 
label = list(months = "Month", member_casual = "Membership")) |>
gtsummary::add_p() |>
gtsummary::as_gt() |>
gt::tab_options(
table.background.color = 'transparent',
table.font.color = "SeaShell",
table_body.vlines.color = "gray20",
table_body.hlines.color = "gray20")

```
:::

## Day

::: article
::: section
::: {.d-flex .align-content-stretch}
::: {.p-2 .align-self-center}
-   [Totals Summary](#total_day_freq)
-   [Membership Summary](#group_day_freq)
-   [Test Association](#sec-chiDays)
:::

::: divBox
:::

::: {.p-1 .align-self-center}
In @tbl-wkdayTotals and @fig-wkdayTotals, there appears to be more trips taken in total between Tuesday through Saturday than Sunday through Monday.

The trend is more complicated in the weekday comparison groups seen in @tbl-wkdayCompare and @fig-wkdayCompare. Trips taken by the casual group rises towards the weekend and dips on days corresponding to days when members are taking more trips. When members are less active, casual riders are more active.

Given, $p < 0.05$, the likelihood of using the service on a particular day, to some extent, seems to depend on membership status. @tbl-chiDays
:::
:::
:::

------------------------------------------------------------------------

### Totals Summary {#total_day_freq}

::: d-flex
::: p-3
```{r}
#| label: tbl-wkdayTotals
#| tbl-cap: Weekday Total Frequency

dplyr::tbl(dbconn, "db/freq_wkday.db") |>
gt::gt() |>
gt::tab_header(title = "Weekday") |>
gt::cols_label(n = "Trips") |>
gt::fmt_number(decimals = 0) |>
gt::tab_options(
table.background.color = 'transparent',
table.font.color = "SeaShell",
table_body.vlines.color = "gray20",
table_body.hlines.color = "gray20",
column_labels.hidden = FALSE
)
```
:::

::: p-3
```{r}
#| label: fig-wkdayTotals
#| fig-cap: Weekday Totals Frequency

dplyr::tbl(dbconn, "db/freq_wkday.db") |>
dplyr::collect() |> 
ggplot2::ggplot(mapping = ggplot2::aes(x = wkday, y = n, fill = n)) +
# To zoom the data a bit
ggplot2::coord_cartesian(ylim = c(4 * 10 ^ 5, NA)) +
ggplot2::geom_col(show.legend = FALSE) +
ggplot2::labs(
title = "Weekday Trip Frequency", 
x = "Day of Week", 
y = "Trips") +
ggplot2::scale_fill_distiller(palette = "YlOrRd") +
ggplot2::theme(
panel.background = ggplot2::element_rect(fill = "#222222", color = NA),
plot.background = ggplot2::element_rect(fill = "#222222", color = NA),
text = ggplot2::element_text(color = "seashell"),
panel.grid = ggplot2::element_blank(),
axis.title.x = ggplot2::element_text(margin = grid::unit(c(5, 5, 5, 5), "mm")),
axis.title.y = ggplot2::element_text(margin = grid::unit(c(5, 5, 5, 5), "mm")),
axis.text.x = ggplot2::element_text(color = "Snow", margin = grid::unit(c(1, 1, 1, 1), "mm")),
axis.text.y = ggplot2::element_text(color = "Snow", margin = grid::unit(c(2, 2, 2, 2), "mm")),
axis.ticks = ggplot2::element_line(color = "LavenderBlush"),
axis.ticks.y = ggplot2::element_blank(),
panel.grid.major.y = ggplot2::element_line(color = "grey30")
)

```
:::
:::

------------------------------------------------------------------------

### Membership Summary {#group_day_freq}

::: d-flex
::: p-3
```{r}
#| label: tbl-wkdayCompare
#| tbl-cap: Weekday Group Frequency

dplyr::tbl(dbconn, "db/freqCompare_wkday.db") |>
gt::gt(groupname_col = "wkday", row_group_as_column = TRUE) |>
gt::tab_header(title = "Weekday to Membership") |>
gt::cols_label(n = "Trips", member_casual = "Membership") |>
gt::fmt_number(decimals = 0) |>
gt::tab_options(
table.background.color = 'transparent',
table.font.color = "SeaShell",
table_body.vlines.color = "gray20",
table_body.hlines.color = "gray20",
column_labels.hidden = FALSE)

```
:::

::: {.ml-2 .align-self-center}
```{r}
#| label: fig-wkdayCompare
#| fig-cap: Weekday Group Frequency

dplyr::tbl(dbconn, "db/freqCompare_wkday.db") |>
ggplot2::ggplot(mapping = ggplot2::aes(x = wkday, y = n, fill = n)) +
ggplot2::geom_col(show.legend = TRUE) +
ggplot2::facet_grid(rows = "member_casual") +
ggplot2::scale_fill_distiller(
palette = "YlGnBu", 
name = "Subscriber Status") +
ggplot2::labs(title = "Weekday to Membership", x = "Day", y = "Trips") +
ggplot2::theme(
panel.background = ggplot2::element_rect(fill = "#222222", color = NA),
plot.background = ggplot2::element_rect(fill = "#222222", color = NA),
text = ggplot2::element_text(color = "seashell"),
panel.grid = ggplot2::element_blank(),
axis.title.x = ggplot2::element_text(margin = grid::unit(c(5, 5, 5, 5), "mm")),
axis.title.y = ggplot2::element_text(margin = grid::unit(c(5, 5, 5, 5), "mm")),
axis.text.x = ggplot2::element_text(color = "Snow", margin = grid::unit(c(1, 1, 1, 1), "mm")),
axis.text.y = ggplot2::element_text(color = "Snow", margin = grid::unit(c(2, 2, 2, 2), "mm")),
axis.ticks = ggplot2::element_line(color = "LavenderBlush"),
axis.ticks.y = ggplot2::element_blank(),
panel.grid.major.y = ggplot2::element_line(color = "grey30"),
legend.background = ggplot2::element_rect(fill = "#222222"))

```
:::
:::

------------------------------------------------------------------------

### Testing the association between day and membership {#sec-chiDays}

```{r}
#| label: tbl-chiDays

# For the week days  comparison
dplyr::tbl(dbconn, tblPath_fltrd) |>
dplyr::select(member_casual, started_at) |>
dplyr::mutate(wkday = lubridate::wday(started_at, label = TRUE, abbr = TRUE)) |>
dplyr::collect() |>
dplyr::mutate(wkday = forcats::as_factor(wkday),
wkday = forcats::fct_inorder(wkday)) |>
gtsummary::tbl_summary(
by = member_casual, 
label = list(wkday = "Day", member_casual = "Membership")) |>
gtsummary::add_p() |>
gtsummary::as_gt() |>
gt::tab_options(
table.background.color = 'transparent',
table.font.color = "SeaShell",
table_body.vlines.color = "gray20",
table_body.hlines.color = "gray20")

```
:::

## Hour

::: article
::: section
::: {.d-flex .align-content-stretch}
::: {.p-3 .align-self-center}
-   [Totals Summary](#total_hour_freq)
-   [Membership Summary](#group_hour_freq)
-   [Test Association](#sec-chiHours)
:::

::: divBox
:::

::: {.p-3 .align-self-center}
The overall trend follows the typical work day cycle where one would expect to see with spikes in the mornings and evenings. @tbl-hourTotals @fig-hourTotals

There is a noted discrepency between member and casual use during peak commute hours. Members have more notable spike during morning commute hours than casuals, which appears more flat throughout the day. @tbl-hourCompare  @fig-hourCompare.

Given, $p < 0.05$, members and casuals tend to take trips at different hours of the day. @tbl-chiHours

:::
:::
:::

------------------------------------------------------------------------

### Totals Summary {#total_hour_freq}

::: {.d-flex .justify-content-around}
```{r}
#| label: simplifyHoursFormat
#| echo: false

hours_of_Riders <- dplyr::tbl(dbconn, "db/freq_hours.db") |>
dplyr::collect()

x <-
stringr::str_sub_all(hours_of_Riders[[1]], start = 1, end = 2) |>
as.character() |>
stringr::str_remove(pattern = "^0")


y <- 
stringr::str_sub(hours_of_Riders[[1]], start = -2, end = -1) |>
stringr::str_to_lower()

simpleTimes <- stringr::str_c(x, sep = " ", y)

hours_of_Riders[[1]] <- simpleTimes
```

::: {.p-3 .tableScroller}
```{r}
#| label: tbl-hourTotals
#| tbl-cap: Total freqeuncy by the hour of day

hours_of_Riders |>
dplyr::select(hour, Total_Riders) |>
gt::gt() |>
gt::tab_header(
title = "Hour"
) |>
gt::cols_label(hour = "Hour", Total_Riders = "Trips") |>
gt::fmt_number(decimals = 0) |>
gt::tab_options(
table.background.color = 'transparent',
table.font.color = "SeaShell",
table_body.vlines.color = "gray20",
table_body.hlines.color = "gray20",
column_labels.hidden = FALSE)
```
:::

::: {.p-3 .flex-grow-1}
```{r}
#| label: 'fig-hourTotals'
#| fig-cap: "Total frequency by hour of day."

hours_of_Riders |>
ggplot2::ggplot(
mapping = ggplot2::aes(
x = reorder(hour, .data$index),
y = Total_Riders,
fill = Total_Riders)) +
ggplot2::geom_col(show.legend = FALSE) +
#ggplot2::coord_radial(start = 2 * pi, inner.radius = .2) +
ggplot2::scale_fill_distiller(palette = "YlOrRd") +
ggplot2::scale_x_discrete(guide = ggplot2::guide_axis(n.dodge = 1, angle = 45)) +
ggplot2::labs(title = "Hour of Day", x = "Hour", y = "Trips") +
ggplot2::theme(
panel.background = ggplot2::element_rect(fill = "#222222", color = NA),
plot.background = ggplot2::element_rect(fill = "#222222", color = NA),
text = ggplot2::element_text(color = "seashell"),
panel.grid = ggplot2::element_blank(),
axis.title.x = ggplot2::element_text(margin = grid::unit(c(5, 5, 5, 5), "mm")),
axis.title.y = ggplot2::element_text(margin = grid::unit(c(5, 5, 5, 5), "mm")),
axis.text.x = ggplot2::element_text(color = "Snow", margin = grid::unit(c(1, 1, 1, 1), "mm")),
axis.text.y = ggplot2::element_text(color = "Snow", margin = grid::unit(c(2, 2, 2, 2), "mm")),
axis.ticks = ggplot2::element_line(color = "LavenderBlush"),
axis.ticks.y = ggplot2::element_blank(),
panel.grid.major.y = ggplot2::element_line(color = "grey30")
)

```
:::
:::

------------------------------------------------------------------------

### Membership Summary

::: {.d-flex .justify-content-around .align-content-stretch}
::: {.p-3 .tableScroller}
```{r}
#| label: tbl-hourCompare
#| tbl-cap: Grouped hour frequency


hour_tbl <- 
dplyr::tbl(dbconn, "db/freqCompare_hours.db") |>
dplyr::collect() |>
dplyr::mutate(
hour = forcats::as_factor(hour), 
hour = forcats::fct_inorder(hour),
Total_Riders = as.integer(Total_Riders))

x <-
stringr::str_sub_all(hour_tbl[[2]], start = 1, end = 2) |>
as.character() |>
stringr::str_remove(pattern = "^0")


y <- 
stringr::str_sub(hour_tbl[[2]], start = -2, end = -1) |>
stringr::str_to_lower()

simpleTimes <- stringr::str_c(x, sep = " ", y)

hour_tbl[[2]] <- simpleTimes

hour_tbl <- hour_tbl |>
dplyr::mutate(
hour = forcats::as_factor(hour),
hour = forcats::fct_inorder(hour))

hour_tbl |>
dplyr::select(member_casual:Total_Riders) |>
gt::gt(
groupname_col = "hour", 
row_group_as_column = TRUE) |>
gt::fmt_number(decimals = 0) |>
gt::tab_header(
title = "Hour to Membership") |>
gt::cols_label(Total_Riders = "Trips", member_casual = "Membership") |>
gt::tab_options(
table.background.color = 'transparent',
table.font.color = "SeaShell",
table_body.vlines.color = "gray20",
table_body.hlines.color = "gray20",
column_labels.hidden = FALSE)

```
:::

::: {.p-3 .align-self-center}
```{r}
#| label: fig-hourCompare
#| fig-cap: Grouped hour frequency

hour_tbl |>
ggplot2::ggplot(ggplot2::aes(x = hour, y = Total_Riders, fill = Total_Riders)) +
ggplot2::geom_col(show.legend = TRUE) +
ggplot2::facet_grid(rows = "member_casual") +
ggplot2::scale_fill_distiller(
palette = "YlGnBu", 
name = ""
) +
ggplot2::scale_x_discrete(
guide = ggplot2::guide_axis(n.dodge = 1, angle = 45)
) +
ggplot2::labs(title = "Hour to Membership", x = "Hour", y = "Trips") +
ggplot2::theme(
panel.background = ggplot2::element_rect(fill = "#222222", color = NA),
plot.background = ggplot2::element_rect(fill = "#222222", color = NA),
text = ggplot2::element_text(color = "seashell"),
panel.grid = ggplot2::element_blank(),
axis.title.x = ggplot2::element_text(margin = grid::unit(c(5, 5, 5, 5), "mm")),
axis.title.y = ggplot2::element_text(margin = grid::unit(c(5, 5, 5, 5), "mm")),
axis.text.x = ggplot2::element_text(color = "Snow", margin = grid::unit(c(1, 1, 1, 1), "mm")),
axis.text.y = ggplot2::element_text(color = "Snow", margin = grid::unit(c(2, 2, 2, 2), "mm")),
axis.ticks = ggplot2::element_line(color = "LavenderBlush"),
axis.ticks.y = ggplot2::element_blank(),
panel.grid.major.y = ggplot2::element_line(color = "grey30"),
legend.background = ggplot2::element_rect(fill = "#222222"),
panel.spacing = ggplot2::unit(4, "mm")
)

```
:::
:::

### Can the hour of the day predict membership? {#sec-chiHours}

```{r}
#| label: tbl-chiHours
#| tbl-cap: "Can the hour of the day correlate to a binary outcome, such as membership?"

# conversion of the datetime column to a new time only column for hour of day
hour_tbl <- dplyr::tbl(dbconn, tblPath_fltrd, check_from = FALSE) |>
dplyr::select(started_at, member_casual) |>
dplyr::mutate("hour" = lubridate::hour(started_at)) |>
dplyr::arrange(hour) |>
dplyr::collect() |>
dplyr::mutate(
hour = hms::hms(hours = hour),
# Need the 12 hour format with am and pm
hour = format(strptime(hour, format = "%H"), "%r"),
hour = forcats::as_factor(hour),
hour = forcats::fct_inorder(hour)
)

x <-
stringr::str_sub_all(hour_tbl[[3]], start = 1, end = 2) |>
as.character() |>
stringr::str_remove(pattern = "^0")


y <- 
stringr::str_sub(hour_tbl[[3]], start = -2, end = -1) |>
stringr::str_to_lower()

simpleTimes <- stringr::str_c(x, sep = " ", y)

hour_tbl[[3]] <- simpleTimes

# Need to reapply forcats functions to retain time order
hour_tbl |>
dplyr::select(hour, member_casual) |>
dplyr::mutate(
hour = forcats::as_factor(hour),
hour = forcats::fct_inorder(hour)
) |>
gtsummary::tbl_summary(by = member_casual, label = list(hour = "Hour", member_casual = "Membership")) |>
gtsummary::add_p() |>
gtsummary::as_gt() |>
gt::tab_options(
table.background.color = 'transparent',
table.font.color = "SeaShell",
table_body.vlines.color = "gray20",
table_body.hlines.color = "gray20")

```



:::

## Distance

::: article
::: section
::: {.d-flex .align-content-stretch}
::: {.p-3 .align-self-center}
-   [Totals Summary](#total_miles_freq)
-   [Membership Summary](#group_miles_freq)
-   [Test Association](#sec-logMiles)
:::

::: divBox
:::

::: {.p-1 .align-self-center}
The distance of most observed trips in @tbl-milesTotals and @fig-milesTotals fall in between 0.3 to 3 miles.

The groups comparison seen in @tbl-milesCompare and @fig-milesCompare show the same pattern. The casual and member differ mainly in overall scale of trips taken between the 0.3 and 3 mile trip distances.

$\beta_1 < 0$, members are less likely to ride as distance traveled in a given trip increases. So, members tend to take shorter trips compared to casual users. @tbl-logMiles
:::
:::
:::

------------------------------------------------------------------------

### Totals Summary {#total_miles_freq}

::: {.d-flex .justify-content-around}
::: {.p-3 .tableScroller}
```{r}
#| label: tbl-milesTotals
#| tbl-cap: Miles Total Frequency

dplyr::tbl(dbconn, "db/freq_miles.db") |>
dplyr::arrange(miles) |>
dplyr::collect() |>
dplyr::mutate(
miles = forcats::as_factor(miles),
miles = forcats::fct_inorder(miles)
) |>
gt::gt() |>
gt::cols_label(miles = "Miles", n = "Trips") |>
gt::fmt_number(decimals = 0) |>
gt::tab_header(title = "Distance") |>
gt::tab_options(
table.background.color = 'transparent',
table.font.color = "SeaShell",
table_body.vlines.color = "gray20",
table_body.hlines.color = "gray20"
)
```
:::

::: p-3
```{r}
#| label: fig-milesTotals
#| fig-cap: Miles Total Frequency

dplyr::tbl(dbconn, "db/freq_miles.db") |>
dplyr::collect() |>
dplyr::mutate(
miles = forcats::as_factor(miles),
miles = forcats::fct_inorder(miles)
) |>
dplyr::rename("Trips" = n, "Miles" = miles) |>
ggplot2::ggplot(mapping = ggplot2::aes(x = Miles, y = Trips, fill = Trips)) +
ggplot2::geom_col(show.legend = FALSE) +
ggplot2::scale_fill_distiller(palette = "YlOrRd") +
ggplot2::labs(title = "Distance") +
ggplot2::scale_x_discrete(guide = ggplot2::guide_axis(n.dodge = 1, angle = 45)) +
ggplot2::theme(
panel.background = ggplot2::element_rect(fill = "#222222", color = NA),
plot.background = ggplot2::element_rect(fill = "#222222", color = NA),
text = ggplot2::element_text(color = "seashell"),
panel.grid = ggplot2::element_blank(),
axis.title.x = ggplot2::element_text(margin = grid::unit(c(5, 5, 5, 5), "mm")),
axis.title.y = ggplot2::element_text(margin = grid::unit(c(5, 5, 5, 5), "mm")),
axis.text.x = ggplot2::element_text(color = "Snow", margin = grid::unit(c(1, 1, 1, 1), "mm")),
axis.text.y = ggplot2::element_text(color = "Snow", margin = grid::unit(c(2, 2, 2, 2), "mm")),
axis.ticks = ggplot2::element_line(color = "LavenderBlush"),
axis.ticks.y = ggplot2::element_blank(),
panel.grid.major.y = ggplot2::element_line(color = "grey30")
)

```
:::
:::

------------------------------------------------------------------------

### Membership Summary {#group_miles_freq}

::: {.d-flex .justify-content-around}
::: {.p-2 .tableScroller style="max-width: 17vw"}
```{r}
#| label: tbl-milesCompare
#| tbl-cap: Miles Group Frequency

dplyr::tbl(dbconn, "db/freqCompare_miles.db") |>
dplyr::arrange(miles) |>
gt::gt(groupname_col = "miles", row_group_as_column = TRUE) |>
gt::tab_header(title = "Distance by Membership") |>
gt::fmt_number(decimals = 0, ) |>
gt::cols_label(n = "Trips") |>
gt::tab_options(
table.background.color = 'transparent',
table.font.color = "SeaShell",
table_body.vlines.color = "gray20",
table_body.hlines.color = "gray20",
column_labels.hidden = FALSE
)

# For the miles group frequency membership comparison
milesCompare_tbl <- dplyr::tbl(dbconn, tblPath_fltrd, check_from = FALSE) |>
dplyr::select(member_casual, miles) |>
dplyr::collect() |>
dplyr::mutate(miles = dplyr::case_when(
miles >= 1 ~ round(miles, digits = 0),
miles < 1 ~ round(signif(miles, 3), digits = 1)
)) |>
dplyr::arrange(miles) |>
dplyr::mutate(
miles = forcats::as_factor(miles),
miles = forcats::fct_inorder(miles)
)
```
:::

::: p-2
```{r}
#| label: fig-milesCompare
#| fig-cap: Miles Group Frequency

milesCompare_tbl |>
dplyr::group_by(miles, member_casual) |>
dplyr::summarize(n = dplyr::n()) |>
dplyr::ungroup() |>
ggplot2::ggplot(mapping = ggplot2::aes(x = miles, y = n, fill = n)) +
ggplot2::geom_col(show.legend = FALSE) +
ggplot2::facet_grid(rows = ggplot2::vars(member_casual)) +
ggplot2::scale_fill_distiller(palette = "YlGnBu", name = "") +
ggplot2::scale_x_discrete(guide = ggplot2::guide_axis(n.dodge = 1, angle = 45)) +
ggplot2::labs(title = "Distance to Membership", x = "Miles", y = "Trips") +
ggplot2::theme(
panel.background = ggplot2::element_rect(fill = "#222222", color = NA),
plot.background = ggplot2::element_rect(fill = "#222222", color = NA),
text = ggplot2::element_text(color = "seashell"),
panel.grid = ggplot2::element_blank(),
axis.title.x = ggplot2::element_text(margin = grid::unit(c(5, 5, 5, 5), "mm")),
axis.title.y = ggplot2::element_text(margin = grid::unit(c(5, 5, 5, 5), "mm")),
axis.text.x = ggplot2::element_text(color = "Snow", margin = grid::unit(c(1, 1, 1, 1), "mm")),
axis.text.y = ggplot2::element_text(color = "Snow", margin = grid::unit(c(2, 2, 2, 2), "mm")),
axis.ticks = ggplot2::element_line(color = "LavenderBlush"),
axis.ticks.y = ggplot2::element_blank(),
panel.grid.major.y = ggplot2::element_line(color = "grey30"),
legend.background = ggplot2::element_rect(fill = "#222222")
)
```
:::
:::

### Can distance predict a binary outcome? {#sec-logMiles}

```{r}
#| label: tbl-logMiles


miles_asNums <- dplyr::tbl(dbconn, tblPath_fltrd, check_from = FALSE) |>
dplyr::select(member_casual, miles) |>
dplyr::collect() |>
dplyr::mutate(
miles = dplyr::case_when(
miles >= 1 ~ round(miles, digits = 0),
miles < 1 ~ round(signif(miles, 3), 
digits = 1))) |>
dplyr::arrange(miles)

miles_asNums$member_casual <- stringr::str_replace(miles_asNums$member_casual, pattern = "casual", "0")

miles_asNums$member_casual <- stringr::str_replace(miles_asNums$member_casual, pattern = "member", "1")

miles_asNums$member_casual <- miles_asNums$member_casual |> as.integer()

miles_asNums$member_casual <- factor(
miles_asNums$member_casual,
levels = c(0, 1),
labels = c("casual", "member")
)

milesModel <- stats::glm(member_casual ~ miles, data = miles_asNums, family = binomial)

# summary(milesModel)$coefficients

mileStats_tbl <- milesModel |>
gtsummary::tbl_regression(label = list(miles = "Miles", member_casual = "Membership"))


mileStats_tbl |>
gtsummary::as_gt() |>
gt::tab_options(
table.background.color = 'transparent',
table.font.color = "SeaShell",
table_body.vlines.color = "gray20",
table_body.hlines.color = "gray20")


```
:::

## Speed

::: article
::: section
::: {.d-flex .align-content-stretch}
::: {.p-3 .align-self-center}
-   [Totals Summary](#total_mph_freq)
-   [Membership Summary](#group_mph_freq)
-   [Test Association](#sec-logMph)
:::

::: divBox
:::

::: {.p-1 .align-self-center}
The majority of mph observations fall in between 2-12 mph, as seen in @tbl-mphTotals and @fig-mphTotals.

Member mph observations skew towards a higher mph than casual riders, as seen in @tbl-mphCompare and @fig-mphCompare.

Given, $\beta_1 > 0$, members tend to have a higher estimated average speed for the duration of their trips compared to casuals. @tbl-logMph
:::
:::
:::


------------------------------------------------------------------------

### Totals Summary {#total_mph_freq}

::: {.d-flex .align-content-stretch}
::: {.p-3 .tableScroller}
```{r}
#| label: tbl-mphTotals
#| tbl-cap: Mph Total Frequency

dplyr::tbl(dbconn, "db/freq_mph.db") |>
dplyr::arrange(mph) |>
gt::gt() |>
gt::tab_header(title = "MPH") |>
gt::fmt_number(decimals = 0) |>
gt::cols_label(mph = "Mph", n = "Trips") |>
gt::tab_options(
table.background.color = 'transparent',
table.font.color = "SeaShell",
table_body.vlines.color = "gray20",
table_body.hlines.color = "gray20",
column_labels.hidden = FALSE
)
```
:::

::: p-3
```{r}
#| label: fig-mphTotals
#| fig-cap: Mph Total Frequency


dplyr::tbl(dbconn, "db/freq_mph.db") |>
dplyr::collect() |>
ggplot2::ggplot(mapping = ggplot2::aes(x = mph, y = n, color = n)) +
ggplot2::geom_point(show.legend = FALSE) +
ggplot2::labs(
title = "MPH",
x = "Miles per Hour",
y = "Trips"
) +
ggplot2::scale_color_distiller(palette = "YlOrRd") +
ggplot2::theme(
panel.background = ggplot2::element_rect(fill = "#222222", color = NA),
plot.background = ggplot2::element_rect(fill = "#222222", color = NA),
text = ggplot2::element_text(color = "seashell"),
panel.grid = ggplot2::element_blank(),
axis.title.x = ggplot2::element_text(margin = grid::unit(c(5, 5, 5, 5), "mm")),
axis.title.y = ggplot2::element_text(margin = grid::unit(c(5, 5, 5, 5), "mm")),
axis.text.x = ggplot2::element_text(color = "Snow", margin = grid::unit(c(1, 1, 1, 1), "mm")),
axis.text.y = ggplot2::element_text(color = "Snow", margin = grid::unit(c(2, 2, 2, 2), "mm")),
axis.ticks = ggplot2::element_line(color = "LavenderBlush"),
axis.ticks.y = ggplot2::element_blank(),
panel.grid.major.y = ggplot2::element_line(color = "grey30"))

```
:::
:::

------------------------------------------------------------------------

### Membership Summary {#group_mph_freq}

::: {.d-flex .align-content-stretch}
::: {.p-3 .tableScroller}
```{r}
#| label: tbl-mphCompare
#| tbl-cap: Mph Group Frequency

dplyr::tbl(dbconn, "db/freqCompare_mph.db") |>
dplyr::arrange(mph, member_casual) |>
dplyr::collect() |>
gt::gt(groupname_col = "mph", row_group_as_column = TRUE) |>
gt::tab_header(title = "MPH to Membership") |>
gt::fmt_number(decimals = 0) |>
gt::cols_label(mph = "Mph", member_casual = "Membership", n = "Trips") |>
gt::tab_options(
table.background.color = 'transparent',
table.font.color = "SeaShell",
table_body.vlines.color = "gray20",
table_body.hlines.color = "gray20",
column_labels.hidden = FALSE)

```
:::

::: p-3
```{r}
#| label: fig-mphCompare
#| fig-cap: Mph Group Frequency

dplyr::tbl(dbconn, "db/freqCompare_mph.db") |>
dplyr::arrange(mph, member_casual) |>
dplyr::collect() |>
ggplot2::ggplot(mapping = ggplot2::aes(x = mph, y = n, color = member_casual)) +
ggplot2::geom_line() +
ggplot2::scale_color_brewer(palette = "Paired", name = NULL) +
ggplot2::labs(title = "MPH to Membership", x = "Miles per Hour", y = "Trips") +
ggplot2::theme(
panel.background = ggplot2::element_rect(fill = "#222222", color = NA),
plot.background = ggplot2::element_rect(fill = "#222222", color = NA),
text = ggplot2::element_text(color = "seashell"),
panel.grid = ggplot2::element_blank(),
axis.title.x = ggplot2::element_text(margin = grid::unit(c(5, 5, 5, 5), "mm")),
axis.title.y = ggplot2::element_text(margin = grid::unit(c(5, 5, 5, 5), "mm")),
axis.text.x = ggplot2::element_text(color = "Snow", margin = grid::unit(c(1, 1, 1, 1), "mm")),
axis.text.y = ggplot2::element_text(color = "Snow", margin = grid::unit(c(2, 2, 2, 2), "mm")),
axis.ticks = ggplot2::element_line(color = "LavenderBlush"),
axis.ticks.y = ggplot2::element_blank(),
panel.grid.major.y = ggplot2::element_line(color = "grey30"),
legend.background = ggplot2::element_rect(fill = "#222222"))
```
:::
:::

------------------------------------------------------------------------

### Can travel speed predict a binary outcome {#sec-logMph}

```{r}
#| label: tbl-logMph

mph_asNums <- dplyr::tbl(dbconn, tblPath_fltrd, check_from = FALSE) |>
dplyr::select(mph, member_casual) |>
dplyr::mutate(mph = round(mph, digits = 0)) |>
dplyr::arrange(mph) |>
dplyr::collect()


mph_asNums$member_casual <- stringr::str_replace(mph_asNums$member_casual, pattern = "casual", "0")

mph_asNums$member_casual <- stringr::str_replace(mph_asNums$member_casual, pattern = "member", "1")

mph_asNums$member_casual <- mph_asNums$member_casual |> as.integer()

mph_asNums$member_casual <- factor(
mph_asNums$member_casual,
levels = c(0, 1),
labels = c("casual", "member"))

mphModel <- stats::glm(member_casual ~ mph, data = mph_asNums, family = binomial)

mphStats_tbl <- mphModel |>
gtsummary::tbl_regression(label = list(mph = "Mph", member_casual = "Membership"))

mphStats_tbl |>
gtsummary::as_gt() |>
gt::tab_options(
table.background.color = 'transparent',
table.font.color = "SeaShell",
table_body.vlines.color = "gray20",
table_body.hlines.color = "gray20")

```
:::

## Duration

::: article
::: section
::: {.d-flex .align-content-stretch}
::: {.p-3 .align-self-center}
-   [Totals Summary](#total_tripTime_freq)
-   [Membership Summary](#group_tripTime_freq)
-   [Test Association](#sec-logTimes)
:::

::: divBox
:::

::: {.p-1 .align-self-center}
The time riders are usually spending on these trips lies between 5 to 15 minutes, as seen in @tbl-triptimeTotals and @fig-triptimeTotals.

The groups as seen in @tbl-triptimeCompare and @fig-triptimeCompare both follow the totals pattern, largely. At the 42 minute mark in the table and plot, the casual riders count becomes greater than for members. Though members ride more frequently, casual riders are more likely to take longer trips.

Given, $\beta_1 < 0$, members are more likely to take shorter trips in terms of how many minutes they ride for on their trips than casuals. @tbl-logTimes
:::
:::
:::

------------------------------------------------------------------------

### Totals Summary {#total_tripTime_freq}

::: {.d-flex}
::: {.p-3 .tableScroller}
```{r}
#| label: tbl-triptimeTotals
#| tbl-cap: Trip-Time Totals

dplyr::tbl(dbconn, "db/freq_tripTime.db") |>
dplyr::collect() |>
dplyr::arrange(trip_time) |>
#head(n = 20) |>
gt::gt() |>
gt::tab_header(title = "Duration Totals") |>
gt::fmt_number(decimals = 0) |>
gt::cols_label(trip_time = "Minutes", n = "Trips") |>
gt::cols_align(columns = "trip_time", align = "center") |>
gt::fmt_number(decimals = 0) |>
gt::tab_options(
table.background.color = 'transparent',
table.font.color = "SeaShell",
table_body.vlines.color = "gray20",
table_body.hlines.color = "gray20",
table.width = gt::pct(25),
column_labels.hidden = FALSE,
row.striping.include_table_body = TRUE) |>
gt::tab_footnote(
"Total trips taken for the given duration.",
locations =   gt::cells_column_labels(columns = "n"))

```
:::

::: p-3
```{r}
#| label: fig-triptimeTotals
#| fig-cap: Trip-Time Totals

dplyr::tbl(dbconn, "db/freq_tripTime.db") |>
dplyr::collect() |>
ggplot2::ggplot(mapping = ggplot2::aes(x = trip_time, y = n, fill = n)) +
ggplot2::geom_col(show.legend = FALSE) +
ggplot2::labs(title = "Trip Duration Frequency", x = "Duration (minutes)", "Trips") +
ggplot2::scale_fill_distiller(palette = "YlOrRd") +
ggplot2::xlim(NA, 100) +
ggplot2::theme(
panel.background = ggplot2::element_rect(fill = "#222222", color = NA),
plot.background = ggplot2::element_rect(fill = "#222222", color = NA),
text = ggplot2::element_text(color = "seashell"),
panel.grid = ggplot2::element_blank(),
axis.title.x = ggplot2::element_text(margin = grid::unit(c(5, 5, 5, 5), "mm")),
axis.title.y = ggplot2::element_text(margin = grid::unit(c(5, 5, 5, 5), "mm")),
axis.text.x = ggplot2::element_text(color = "Snow", margin = grid::unit(c(1, 1, 1, 1), "mm")),
axis.text.y = ggplot2::element_text(color = "Snow", margin = grid::unit(c(2, 2, 2, 2), "mm")),
axis.ticks = ggplot2::element_line(color = "LavenderBlush"),
axis.ticks.y = ggplot2::element_blank(),
panel.grid.major.y = ggplot2::element_line(color = "grey30")
)
```
:::
:::

------------------------------------------------------------------------

### Membership Summary {#group_tripTime_freq}

::: d-flex
::: {.p-3 .tableScroller}
```{r}
#| label: tbl-triptimeCompare
#| tbl-cap: Trip Time Comparison


dplyr::tbl(dbconn, "db/freqCompare_tripTime.db") |>
dplyr::collect() |>
dplyr::arrange(trip_time, member_casual) |>
gt::gt(groupname_col = "trip_time", row_group_as_column = TRUE) |>
gt::tab_header(title = "Durations by Membership", subtitle = "Measured in minutes.") |>
gt::fmt_number(decimals = 0) |>
gt::cols_label(member_casual = "Membership", n = "Trips") |>
gt::tab_options(
table.background.color = 'transparent',
table.font.color = "SeaShell",
table_body.vlines.color = "gray20",
table_body.hlines.color = "gray20",
column_labels.hidden = FALSE,
) |>
gt::tab_footnote(footnote = "Trip counts by membership status.",
locations = gt::cells_column_labels("n"))

```
:::

::: p-3
```{r}
#| label: fig-triptimeCompare
#| fig-cap: Trip-Time Group Frequency 

dplyr::tbl(dbconn, "db/freqCompare_tripTime.db") |>
ggplot2::ggplot(mapping = ggplot2::aes(x = trip_time, y = n, color = member_casual)) +
ggplot2::geom_line(show.legend = TRUE) +
ggplot2::xlim(NA, 100) +
ggplot2::scale_color_brewer(palette = "Paired", name = "") +
ggplot2::labs(title = "Duration by Membership", x = "Duration (in minutes)", y = "Trips") +
ggplot2::theme(
panel.background = ggplot2::element_rect(fill = "#222222", color = NA),
plot.background = ggplot2::element_rect(fill = "#222222", color = NA),
text = ggplot2::element_text(color = "seashell"),
panel.grid = ggplot2::element_blank(),
axis.title.x = ggplot2::element_text(margin = grid::unit(c(5, 5, 5, 5), "mm")),
axis.title.y = ggplot2::element_text(margin = grid::unit(c(5, 5, 5, 5), "mm")),
axis.text.x = ggplot2::element_text(color = "Snow", margin = grid::unit(c(1, 1, 1, 1), "mm")),
axis.text.y = ggplot2::element_text(color = "Snow", margin = grid::unit(c(2, 2, 2, 2), "mm")),
axis.ticks = ggplot2::element_line(color = "LavenderBlush"),
axis.ticks.y = ggplot2::element_blank(),
panel.grid.major.y = ggplot2::element_line(color = "grey30"),
legend.background = ggplot2::element_rect(fill = "#222222"))
```
:::
:::

------------------------------------------------------------------------

### Can trip duration predict a binary outcome? {#sec-logTimes}

```{r}
#| label: tbl-logTimes

# For the trip times comparison
triptime_asNums <- dplyr::tbl(dbconn, tblPath_fltrd) |>
dplyr::select(member_casual, trip_time) |>
dplyr::mutate(trip_time = round(trip_time, digits = 0)) |>
dplyr::arrange(trip_time) |>
dplyr::collect()

triptime_asNums$member_casual <- stringr::str_replace(triptime_asNums$member_casual, pattern = "casual", "0")

triptime_asNums$member_casual <- stringr::str_replace(triptime_asNums$member_casual, pattern = "member", "1")

triptime_asNums$member_casual <- triptime_asNums$member_casual |> as.integer()

triptime_asNums$member_casual <- factor(
triptime_asNums$member_casual,
levels = c(0, 1),
labels = c("casual", "member")
)

triptimeModel <- stats::glm(member_casual ~ trip_time, data = triptime_asNums, family = binomial)

triptimeStats_tbl <- triptimeModel |>
gtsummary::tbl_regression(label = list(trip_time = "Duration", member_casual = "Membership"))

triptimeStats_tbl |>
gtsummary::as_gt() |>
gt::tab_options(
table.background.color = 'transparent',
table.font.color = "SeaShell",
table_body.vlines.color = "gray20",
table_body.hlines.color = "gray20")

```
:::
:::
:::
:::


## Traffic Flow {#sec-epiflow}

::: {.p-3}
For an interesting birds-eye-view of trip behaviors, see @fig-epiflowNetwork. This is called an epiflow diagram. It is interactive, so circles (nodes) and the lines connecting the nodes can be clicked for more information.  There is also a  drop-down window to further explore the data. The top 34 most traveled stations were used for this visual network diagram. The line thickness roughly corresponds with amount of trips taken, so thicker lines means more trips between nodes. [@moragab]

These are the most active stations. Luckily, there might be a way to further explore the typical high traffic station locations and why they are high traffic. @sec-mapview
:::

::: {#offcanvas13 .offcanvas .offcanvas-start tabindex="-1" aria-labelledby="offcanvas" style="width: auto"}
::: offcanvas-header
::: {.h5 .offcanvas-title}
Creating an Epiflow
:::

::: {.btn-close type="button" data-bs-dismiss="offcanvas" ariaLabel="Close"}
:::
:::

::: offcanvas-body
::: flex-code
```{r}
#| label: createFlows dataframe
#| code-summary: First, creates the frequency of trips taken to and from pairs of stations. We are only going to look deeper into the top 50 most traveled pairs.

flowData <- dplyr::tbl(dbconn,
                       tblPath_fltrd) |>
    dplyr::select(start_station_name,
                  end_station_name) |>
    dplyr::group_by(start_station_name,
                    end_station_name) |>
    dplyr::summarize(n = n()) |>
    dplyr::ungroup() |>
    dplyr::arrange(desc(n)) |>
    dplyr::rename("from_station" = start_station_name,
                  "to_station" = end_station_name) |>
    dplyr::collect() |>
    dplyr::slice_head(n = 50)
```

```{r}
#| label: location stats
#| code-summary: Second, we need statistics but also to combine the statistics for every unique station name. 

locationData <- dplyr::tbl(dbconn,
                           tblPath_fltrd) |>
    dplyr::select(start_station_name,
                  end_station_name,
                  started_at,
                  ended_at,
                  trip_time) |>
    dplyr::group_by(start_station_name,
                    end_station_name
                ) |>
    dplyr::mutate("trip_time" = round(trip_time,
                                      digits = 0)) |>
    dplyr::summarize(
        "trip_count" = dplyr::n(),
        "first_date" = min(started_at),
        "last_date" = max(ended_at),
    ) |>
    dplyr::ungroup() |>
    dplyr::rename("from_station" = start_station_name,
                  "to_station" = end_station_name
               ) |>
    dplyr::arrange(desc(trip_count)) |>
    dplyr::collect()



# Need to combine all names to single column and recalculate 
# or retain other stats.
locationData_pivoted <- locationData |>
    tidyr::pivot_longer(cols = 1:2, 
                        values_to = "allNames") |>
    dplyr::group_by(allNames) |>
    dplyr::summarize("trips_toAndfrom" = sum(trip_count),
                     first_date = min(first_date),
                     last_date = max(last_date),
                     ) |>
    dplyr::arrange(trips_toAndfrom)

```

```{r}
#| label: MakeEpiflows
#| code-summary: Third, creates epiflow objects, which take in a pair of dataframes and creates the flows between them. 

# for all the pairs
ef_test <- epiflows::make_epiflows(flows = flowData,
                                   locations = locationData_pivoted,
                                   num_cases = "trips_toAndfrom")
```
:::
:::
:::

::: {#offcanvas14 .offcanvas .offcanvas-end tabindex="-1" aria-labelledby="offcanvas" style="width: auto"}
::: offcanvas-header
::: {.h5 .offcanvas-title}
Tables
:::

::: {.btn-close type="button" data-bs-dismiss="offcanvas" ariaLabel="Close"}
:::
:::

::: offcanvas-body
::: flex-code
```{r}
#| label: summaryFlowData
#| code-summary: First, just a quick view of the flow data table we made earlier.
#| title: Flow Data View

flowData
```

```{r}
#| label: pivotedLocations
#| code-summary: Second, another quick view, but for thethe location data we pivoted earlier.
#| title: Pivoted Location Data

locationData_pivoted |>
    dplyr::arrange(desc(trips_toAndfrom))
```
:::
:::
:::

::: {.article style="color: Black"}
```{r}
#| label: fig-epiflowNetwork
#| fig-cap: EpiFlow Network
#| echo: false

epiflows::vis_epiflows(ef_test)
```
:::

::: {.d-flex .justify-content-center}
::: {.btn-group role="group" aria-label="third"}
::: {.btn .btn-secondary type="button" data-bs-toggle="offcanvas" data-bs-target="#offcanvas13" aria-controls="offcanvas"}
```{=html}
<i class="bi bi-code-slash" style="color: cornflowerblue"></i>
```
:::

::: {.btn .btn-secondary type="button" data-bs-toggle="offcanvas" data-bs-target="#offcanvas14" aria-controls="offcanvas"}
```{=html}
<i class="bi bi-table" style="color: red;"></i>
```
:::
:::
:::

## Checking the Map {#sec-mapview}
:::{.p-3}
This section was made possible thanks to the latitude and longitude coordinates data provided alongside the stations names. Coming from the epiflow diagram, this should help make the data less abstract. The accordion below expands and collapses four *OpenStreet* maps found in the callout section below. These maps were split for viewing logistics. They contain from the epiflow in the section above. These maps are interactive, so the default views are zoomable and movable. The transparent burst buttons enable snappy zooming-in of the station groups.
:::

::: {#offcanvas20 .offcanvas .offcanvas-start tabindex="-1" aria-labelledby="offcanvas" style="width: auto"}
::: offcanvas-header
::: {.h5 .offcanvas-title}
Code for Mapping
:::

::: {.btn-close type="button" data-bs-dismiss="offcanvas" ariaLabel="Close"}
:::
:::

::: offcanvas-body
::: flex-code
```{r}
#| label: mapData
#| code-summary: "Processing 'flowData' created earlier to include geolocation data for mapview plots."

# All distinct stations in one column
names <- flowData |>
    dplyr::select(from_station,
                  to_station) |>
    tidyr::pivot_longer(cols = 1:2,
                        names_to = NULL,
                        values_to = "station_names") |>
    dplyr::distinct()


# The important geo-coordinates corresponding to station names
mapData <- dplyr::tbl(dbconn,
                      tblPath_fltrd,
                      check_from = FALSE) |>
    dplyr::select(start_station_name,
                  start_lat,
                  start_lng,
                  end_station_name,
                  end_lat,
                  end_lng)

# Filter to include all observations that match the station names listed in 'names'. We need the geo-coordinates alongside the names.
mapData1 <- mapData |>
    dplyr::collect() |>
# Filter, but through a vector of conditions.
    dplyr::filter(start_station_name %in% names[[1]],
                  end_station_name %in% names[[1]]) |>
    dplyr::select(start_station_name:start_lng)


# Had to split 'mapData' into two and pivot into a single table.
mapData2 <- mapData |>
    dplyr::collect() |>
    dplyr::filter(start_station_name %in% names[[1]],
                  end_station_name %in% names[[1]]) |>
    dplyr::select(end_station_name:end_lng)

# Nice grouping
stations_groupMap <- dplyr::bind_rows(mapData1, mapData2) |>
dplyr::select(start_station_name, start_lat, start_lng) |>
dplyr::rename("station_names" = start_station_name,
"lat" = start_lat,
"lng" = start_lng) |>
dplyr::distinct() |>
dplyr::group_by(station_names)

# Setting seed for sampling
set.seed(113)

# Taking 10 random samples from each station_name group
sampled_stations <- stations_groupMap |>
    dplyr::slice_sample(n = 10) |>
    tidyr::drop_na()
```

```{r}
#| label: mapColors
#| code-summary: "Creates a map coloring palette excluding grays."

# All of the r-colors
allPalette <- colors()

# The grays are vast so we don't want those watering down the samples.
colorfulPal <- purrr::discard(allPalette, stringr::str_detect(allPalette, "gr(a|e)y"))

# When we sample the colors, 10 should be slightly more than needed.
n_colors <- 10
```

```{r}
#| label: mapViewer
#| code-summary: First, sourcing the script needed to generate the maps and creating the list of vectors used as input. These vectors are the slices of the top most traveled stations.

slicerVector <- list(c(1:9), c(10:18), c(19:27), c(28:34))
source("Scripts/mapViewer.R")
```

```{r}
#| file: "Scripts/mapViewer.R"
#| eval: false
#| code-summary: "The script used to generate the maps."
#| label: mapViewerScript
```
:::
:::
:::

::: {#accordionParent .accordion .mt-3 .mb-3}
::: accordion-item
::: {#headingOne .accordion-header}
::: {.accordion-button .collapsed type="button" data-bs-toggle="collapse" data-bs-target="#collapseOne" aria-expanded="true" aria-controls="collapseOne" style="background-color: #bbab9b"}
Benson Ave & Church St ... Ellis Ave & 60th St
:::
:::

::: {#collapseOne .accordion-collapse .collapse aria-labelledby="headingOne" data-bs-parent="#accordionParent"}
::: accordion-body
```{r}
#| label: fig-map1
#| fig-cap: "Benson Ave & Church St - Ellis Ave & 60th St"

set.seed(240)
randomColors <- sample(colorfulPal, n_colors)
mapViewer(slicerVector[[1]])

```
:::
:::
:::

::: accordion-item
::: {#headingTwo .accordion-header}
::: {.accordion-button .collapsed type="button" data-bs-toggle="collapse" data-bs-target="#collapseTwo" aria-expanded="false" aria-controls="collapseTwo" style="background-color: #8b6f47"}
Greenview Ave & Fullteron Ave ... Loomis Ave & Lexington St
:::
:::

::: {#collapseTwo .accordion-collapse .collapse aria-labelledby="headingTwo" data-bs-parent="#accordionParent"}
::: accordion-body
```{r}
#| label: fig-map2
#| echo: false
#| fig-cap: "Greenview Ave & Fullteron Ave - Loomis Ave & Lexington St"

set.seed(241)
randomColors <- sample(colorfulPal, n_colors)
mapViewer(slicerVector[[2]])

```
:::
:::
:::

::: accordion-item
::: {#headingThree .accordion-header}
::: {.accordion-button .collapsed type="button" data-bs-toggle="collapse" data-bs-target="#collapseThree" aria-expanded="false" aria-controls="collapseThree" style="background-color: #587e76"}
Michigan Ave & Oak St ... State St & 33rd St
:::
:::

::: {#collapseThree .accordion-collapse .collapse aria-labelledby="headingThree" data-bs-parent="#accordionParent"}
::: accordion-body
```{r}
#| label: fig-map3
#| echo: false
#| fig-cap: "Michigan Ave & Oak St - State St & 33rd St"

set.seed(242)
randomColors <- sample(colorfulPal, n_colors)
mapViewer(slicerVector[[3]])

```
:::
:::
:::

::: accordion-item
::: {#headingFour .accordion-header}
::: {.accordion-button .collapsed type="button" data-bs-toggle="collapse" data-bs-target="#collapseFour" aria-expanded="false" aria-controls="collapseFour" style="background-color: #4f3222"}
Street Dr & Grand Ave ... Woodlawn Ave & 55th St
:::
:::

::: {#collapseFour .accordion-collapse .collapse aria-labelledby="headingFour" data-bs-parent="#accordionParent"}
::: accordion-body
```{r}
#| label: fig-map4
#| fig-cap: "Street Dr & Grand Ave - Woodlawn Ave & 55th St"

set.seed(243)
randomColors <- sample(colorfulPal, n_colors)
mapViewer(slicerVector[[4]])
```
:::
:::
:::
:::

:::{.p-2}
For example, suppose *University Ave & 57th St* was selected in the epiflow. As it happens this is at the heart of the University of Chicago. So where does the traffic to and from this location usually flow to? Selecting one of the other nodes highlighted with flows directing away from the previous node, is *Kimbark Ave and 53rd St*. This location is seated adjacent to the *Vue 53 Apartments* complex in the map view. 
:::

# Where to Next?

Having explored the possible associations between behaviors of annual members and casuals, several correlations with potential predictive power were found. To test the correlation between two categorical variables, such as membership to bicycle type, month, day, and hour, a chi-squared test was used. For correlations between a dependent binary categorical variable and a quantitative or continuous variable, such as membership to miles, minutes, and mph, binary logistic regression was performed. With these insights in hand, stakeholders could make more sound decisions to increase use of the service. It might, for example, be desired to increase annual membership rates. Increasing overall use across all types of users could be another desired outcome.

It lends itself to suggestion that individual members are using the service multiple times a week. In that light, it is likely not the case, or at best unclear, whether there is a discernably larger volume of unique invidual members making use of the service. Further statistical analysis would likely be one of the next steps to verify the association of certain locations being more or less likely to be traveled than others. A look into the real-life maps of the top traveled locations and traffic flows suggests that universities, shopping centers, big companies, and apartment complexes near said locations tend to have the highest volumes.

Those using the service as annual members, in comparison to casual users, tend to use the service more consistently throughout the year; use the manual, or *classic*, bicycles; take more trips during the work week as opposed to the weekend; are more likely to take shorter trips, and travel at a faster pace. To paint a picture of an annual subscriber, or member: A member is someone with somewhere to be. They use a bicycle as someone would use a car. Also, they use the service for probably more than one reason, much like *"killing two birds with one stone."* For instance, members might be saving money, time stuck in traffic, *'going green'*, and getting some exercise while they are at it.   

In contrast, the picture of a casual user would be something along the lines of: Someone who needs something to do. A casual is someone who might be visiting Chicago on vacation. This user takes longer, slower rides. Maybe the occasional weekend ride around the city and or park. Instead of renting a car, they decide to use a bicycle to spend their time. Casuals seem more like fair-weather riders, so they stick to the warmer months. The casual user may or may not be on the fence of becoming an annual subscriber.

With these images in mind, here are some suggestions to improve membership. To put it simply, one should target what is keeping people from being members. Factros such as a lack of stations within short walking distance to their residence, or lack of stations at their destination. For electric bicycles, perhaps the charge does not last, or not enough charging stations are around. That could explain the lower use of electric compared to classic bikes. People could be trying it out as a trial for a few days to weeks but find that the service is unreliable for them.


```{r}
#| eval: false
#| include: false

# If you need to drop any tables without deleting the entire database.
source("Scripts/duckDrops.R")
```

---
title: "Bike-Sharing in the Streets of Chicago"
author: "Eric Mossotti"
date: "05-12-2024"
bibliography: references.bib
repo: https://github.com/ericMossotti/Bike_Share
source: index.qmd
abstract-title: "Objective"
abstract: "Communicate data-driven insights to stakeholders."
description-meta: "Communicate data-driven insights to stakeholders."

code-links:
    - text: "Project Repo"
      href: repo
code-fold: true
code-copy: hover
code-overflow: wrap
code-tools: true
code-link: true

toc-expand: true
toc: true
#toc_float: true
number-sections: true

smooth-scroll: true
fig-responsive: true
echo: true

#font: merriweather, futura
---

```{r, include = FALSE}

knitr::opts_chunk$set(message = FALSE, 
                      warning = FALSE)
```

------------------------------------------------------------------------

# Design and Purpose

::: {#offcanvas1 .offcanvas .offcanvas-end tabindex="-1" aria-labelledby="offcanvas" style="width: auto"}
::: offcanvas-header
::: {#offcanvasLabel .h5 .offcanvas-title}
Import Processing Code
:::

::: {.btn-close type="button" data-bs-dismiss="offcanvas" ariaLabel="Close"}
:::
:::

::: offcanvas-body
::: flex-code
```{r}
#| label: importOrConnect
#| code-summary: First, we decide whether to download and do the necessary initial processing steps or skip that if we have already done this and are just tinkering around with the project. 

if(exists("dbconn") == FALSE &&
   dir.exists("db") == FALSE) {
    # Script to keep this document less cluttered.
    source("import_clean_initial.R")
} else {
    # You will have to change original_nobs if you use            
    #  different data. It helps with tinkering when 
    #   you want to skip the import step.
    original_nobs <- as.integer(5719877)
    
    tblPath <- "db/data.db"
    
    dbconn <- DBI::dbConnect(
        duckdb::duckdb(),
        dbdir = tblPath,
        read_only = FALSE,
        check_from = FALSE
    )
}

tblPath <- "db/data.db"
dupelessPath <- "db/dupeless.db"
tblPath_fltrd <- "db/data_fltrd.db"

```

```{r}
#| label: importProcessScript
#| code-summary: This then would be executed if conditions were met. Usually, this would only execute if there is no db folder and associated files.
#| file: "import_clean_initial.R"
#| eval: false 
```

```{r}
#| label: tbl-dbList
#| code-summary: It would now be helpful to verify the tables written so far.
#| tbl-cap: Database Table List

dbList <- duckdb::dbListTables(dbconn) |>
    data.frame() |>
    gt::gt() |>
    gt::tab_header(
        title = "Database Tables",
        subtitle = "List of table paths in our DuckDB") |>
    gt::cols_label(
        "duckdb..dbListTables.dbconn." = "Table Paths"
    ) |>
    gt::tab_options(
        table.background.color = "transparent",
        table.font.color = "SeaShell",
        column_labels.hidden = TRUE,
        row.striping.background_color = "gray10",
        row.striping.include_table_body = TRUE,
        table.font.size = gt::px(13)
    )

dbList
```
:::
:::
:::

## Stakeholders

Starting off, the stakeholders can be identified as Divvy, Lyft, and the City of Chicago Department of Transportation. As such this analysis is meant to provide stakeholders with data-based guidance to better server the residents of Chicago and users of the Divvy bike sharing service. Improving air quality, promoting economic recovery, and reducing traffic congestion were among the rationale for Divvy's implementation. [@aboutdi]

## Source

The raw 2023 dataset was directly sourced from Divvy Data. [@divvyda]

## Design

Another worthy goal of this analysis is to achieve reproducibility and efficiency. To help future analyst teams move this research forward, this project tried to provide adequate code documentation and best practices with regards to clean code and modularity.

For example, it was helpful to incorporate certain design decisions to eliminate re-downloading and re-processing of data. For users conducting analysis over the course of days-months on this dataset, following initial download and processing, it is now possible to simply reconnect to the single database file which contains all of the original data including tables written throughout the course of the analysis.

The underlying code incorporates an if-else decision, which includes a source code script that handles the initial processing and establishes the database filesystem. Choosing a persistent DuckDB filesystem (as opposed to purely in-memory) seemed optimal in terms of the simplicity and cost-effectiveness of SQL database queries while retaining progress made over extended periods. [@whyduck]

# Tidying

The starting observation count was 5,719,877. Then 1,388,170 incomplete observations were then removed by the initial processing script.




:::{.d-flex .justify-content-center}
::: {.callout-note title="Click the icons such as these for code related to the sections they are found" style="width: 60%"}
::: {.btn .btn-secondary type="button" data-bs-toggle="offcanvas" data-bs-target="#offcanvas1" aria-controls="offcanvas"}
More code processing steps are available via the code icon links scattered throughout the document, such as the one below. The code summaries are given to help supplement the reader with context to help understand how and why the data is processed throughout: 
```{=html}
<i class="bi bi-code-slash" style="font-size: 1.5rem; color: cornflowerblue"></i>
```
:::
:::
:::

## Duplicates

::: {#offcanvas2 .offcanvas .offcanvas-end tabindex="-1" aria-labelledby="offcanvas" style="width: auto"}
::: offcanvas-header
::: {.h5 .offcanvas-title}
Code to Remove Duplicates
:::
::: {.btn-close type="button" data-bs-dismiss="offcanvas" ariaLabel="Close"}
:::
:::
::: offcanvas-body
::: flex-code
```{r}
#| label: duplicates_gt
#| code-summary: First, create a table containing the duplicated observations.

# This is a separate table used to analyze the observations 
#  returned as not distinct (n > 1). 
#   This adds an extra column, labeled "n".
dupeTable <- dplyr::tbl(dbconn,
                        tblPath,
                        check_from = FALSE) |>
    dplyr::select(started_at:end_station_name) |>
    # Counts of unique rows added for column 'n'
    dplyr::add_count(started_at,
                     ended_at,
                     start_station_name,
                     end_station_name) |>
    # Only observations that have been duplicated 
    #  1 or more times are shown.
    dplyr::filter(n > 1) |>
    # We want to see all rows, 
    #  not just one row for each obs.
    dplyr::ungroup() |>
    dplyr::arrange(started_at) |>
    dplyr::collect()
```

```{r}
#| label: duplicateObs count
#| code-summary: Record a count of distinct duplicates and total observations.

distinctCopiesCount <- dupeTable |>
    dplyr::distinct(n) |>
    as.integer() 

duplicateObs <- length(dupeTable[[1]])
```

```{r}
#| label: undupedTable
#| code-summary: Create a table of the now unduplicated observations we saw before.

# The issue is, we need to get rid of not all of these rows, but just the extra duplicate observations.
# 
# If there were 2 rows of duplicates, one would want to end up with 1 row after removing the extras.
undupedTable <- 
dupeTable |>
dplyr::distinct(started_at, 
start_station_name, 
ended_at, 
end_station_name)
```

```{r}
#| label: incorrect distinct obs count
#| code-summary: Record a count of the incorrect observations.

# Run an incorrect count on how many rows or observations there are in the dataset.
count_incorrectDists <- dplyr::tbl(dbconn,
                                   tblPath,
                                   check_from = FALSE) |>
    dplyr::distinct(dplyr::pick("ride_id")) |>
    dplyr::count(name = "Incorrect Distinct Observations") |>
    dplyr::collect() |>
    as.integer()
```

```{r}
#| label: count_correctDists count
#| code-summary: Record a count of the correct observations.

# For the correct count of obs
count_correctDists <- dplyr::tbl(dbconn,
                                 tblPath,
                                 check_from = FALSE) |>
    dplyr::distinct(
        dplyr::pick(
            "started_at",
            "start_station_name",
            "ended_at",
            "end_station_name")) |>
    dplyr::count() |>
    dplyr::collect() |>
    as.integer()
```

```{r}
#| label: 'overwrite file with correct obs'
#| code-summary: Write the unduplicated data to the database.

dupelessPath <- "db/dupeless.db"
 
dplyr::tbl(dbconn,
           tblPath,
           check_from = FALSE) |>
    dplyr::select(ride_id:trip_time) |>
    dplyr::distinct(started_at,
                    start_station_name,
                    ended_at,
                    end_station_name,
                    .keep_all = TRUE) |>
    dplyr::arrange(started_at) |>
    dplyr::collect() |>
    duckdb::dbWriteTable(conn = dbconn,
                         name = dupelessPath,
                         overwrite = TRUE,
                         check_from = FALSE)
```

```{r}
#| label: make_dupeTable
#| code-summary: Make the duplicates table. 

gtDupes <- dupeTable |>
dplyr::group_by(started_at) |>
gt::gt(
rowname_col = "row",
groupname_col = "started_at",
row_group_as_column = TRUE
) |>
gt::tab_style(
style = list(
gt::cell_text(weight = "bold", align = "center"),
gt::cell_borders(sides = c("bottom"))
),
locations = gt::cells_column_labels(gt::everything())
) |>
gt::tab_style(
style = list(
gt::cell_borders(sides = c("left", "right"), color = "transparent"),
gt::cell_text(align = "center", v_align = "middle")
),
locations = gt::cells_body(gt::everything())
) |>
gt::data_color(
columns = start_station_name,
target_columns = gt::everything(),
method = "auto",
palette = "basetheme::brutal"
) |>
gt::tab_header(title = "A view of duplicated observations", subtitle = "Grouping follows the starting date-time value") |>
gt::tab_options(
heading.title.font.weight = "bolder",
heading.subtitle.font.weight = "lighter",
heading.align = "center",
table.background.color = "transparent",
table.font.color = "SeaShell",
table.font.size = gt::pct(75),
)

```

```{r}
#| label: make_undupedTable
#| code-summary: Make the unduped table. 

gt_undupes <- undupedTable |>
dplyr::collect() |>
dplyr::group_by(started_at) |>
gt::gt(
rowname_col = "row",
groupname_col = "started_at",
row_group_as_column = TRUE
) |>
gt::fmt_number(decimals = 0) |>

gt::tab_style(
style = list(
gt::cell_text(weight = "bold", align = "center"),
gt::cell_borders(sides = c("bottom"))
),
locations = gt::cells_column_labels(gt::everything())
) |>
gt::tab_style(
style = list(
gt::cell_borders(sides = c("left", "right")),
gt::cell_text(align = "center", v_align = "middle")
),
locations = gt::cells_body(gt::everything())
) |>
gt::data_color(
columns = start_station_name,
target_columns = gt::everything(),
method = "auto",
palette = "basetheme::brutal"
) |>
gt::tab_header(title = "After duplicates were removed", subtitle = "Same grouping") |>
gt::tab_options(
heading.title.font.weight = "bolder",
heading.subtitle.font.weight = "lighter",
heading.align = "center",
table.background.color = "transparent",
table.font.color = "SeaShell",
table.font.size = gt::pct(75)
)

```

```{r}
#| label: make_summaryProcessTable
#| code-summary: Create an observation history table that summarizes the cleaning so far.

# To see the history of obs in our dataset.
summaryProcessTable <- tidyr::tribble(
~ "Observations",
~ "Counts",
"Original   ",
original_nobs,
"Processed   ",
count_incorrectDists,
"Duplicates   ",
(count_incorrectDists - count_correctDists),
"Total Corrected   ",
count_correctDists
) |>
gt::gt(rownames_to_stub = FALSE) |>
gt::tab_header(title = "Tallying Observations") |>
gt::tab_footnote(
footnote = gt::md("Row counts throughout the cleaning steps."),
locations = gt::cells_column_labels(columns = Counts)
) |>
gt::tab_style(
style = list(
gt::cell_borders(sides = "bottom"),
gt::cell_text(
align = "left",
stretch = "semi-expanded",
whitespace = "break-spaces"
)
),
locations = gt::cells_body(gt::everything())
) |>
gt::tab_style(
gt::cell_text(
align = "center",
stretch = "semi-expanded",
whitespace = "break-spaces"
),
locations = list(
gt::cells_title(groups = c("title", "subtitle")),
gt::cells_column_labels(gt::everything())
)
) |>
gt::fmt_number(decimals = 0) |>
gt::tab_options(
quarto.use_bootstrap = TRUE,
column_labels.font.weight = "bold",
table.background.color = "transparent",
table.font.color = "SeaShell",
row.striping.background_color = "gray10",
row.striping.include_table_body = TRUE
)

```
:::
:::
:::

::: {.p-3 }
Now the question arises: How does one check the data for duplicates? That is what this section covers, alongside how to only remove what is needed. Care is needed because it might not necessarily be the case that each observation, or *obs* for short, is unique because a column contains all unique values.

All of the values in the **ride_id** column were found to be unique. However, not all of the obs, or rows, were found to be truly unique. Other columns such as **start_time**, **end_time**, **start_station**, and **end_station** were used to verify if an obs was distinct. These would have more granular information, down to the second, a given trip's starting and ending time and location. In this analysis, it was assumed that obs having the same starting and ending date-time and station despite having two different rider IDs was a mistake.
:::

::: {.tableScroller .p-3 .auto-fit}
```{r}
#| label: tbl-duplicates
#| tbl-cap: Duplicates Table
#| echo: false

gtDupes
```
:::

:::{.p-3}
Although, it is actually unknown how that error would happen. It could have been assumed that one person checked out multiple bikes at once. In that instance, each bike would be assigned a unique **ride_id**. That, however, has only happened **18** times over a year. Since it is only one copy every time, red flags were raised. Perhaps trips could be grouped where one person pays for a other riders? If that were the case, then why is there always one duplicate?

In @tbl-duplicates, duplicate observations were listed and grouped by color. Contrast this with @tbl-unduplicated, which has removed the extra copy of the observation while preserving the observation itself. Of the duplicates, each had one extra copy. It was noted that the number of rows in the duplicates table is 36. Each duplicated observation has one duplicate, where **n** is always the value 2. So the expected removed obs was 18. A complication involved how to remove not all obs but just one extra duplicate observation from each.
:::

::: {.p-3 .tableScroller .auto-fit}
```{r}
#| label: tbl-unduplicated
#| tbl-cap: Un-duplicated Table
#| echo: false

gt_undupes
```
:::

:::{.p-3}
The count of distinct n-values for the un-duplicated table was 18. Then a count of observations in the dataset were recorded. The incorrect number of obs was 4,331,707. The correct obs after removing duplicated obs was 4,331,689. In short, 18 additional obs were removed.  @tbl-observationHistory
:::
:::{.p-3}
```{r}
#| label: tbl-observationHistory
#| tbl-cap: Observation Processing History
#| echo: false

summaryProcessTable
```
:::

:::{.d-flex .justify-content-center}
::: {.btn .btn-secondary type="button" data-bs-toggle="offcanvas" data-bs-target="#offcanvas2" aria-controls="offcanvas"}
```{=html}
<i class="bi bi-code-slash" style="font-size: 1.5rem; color: cornflowerblue"></i>
```
:::
:::

## Outliers

Observations that were deemed erroneous or not useful for identifying trends in how the service is utilized by members and casual users were filtered out. It is good practice to keep note of these errors as they might explain some differences in how members and casual use the service.

It was determined that trips with negative minutes were errors. Trips less than 1 minute but greater than 0 were noted, but removed, as they might skew the statistics we derive from this data too much later on. The underlying reason for low trip times could be from people just wanting to try it out briefly before committing or quickly realized they did not like it. There were observations that did not make much sense, but most of the data was retained.

As in the first part, an **if-else** decision was chosen because it makes testing easier. An external database filtering script was chosen to shorten the code needed inside the main Quarto document itself. The data from which the rest of the tables are based on are used for the rest of the analysis.

::: {.d-flex .justify-content-center max-width="auto"}
::: {.callout-note title="Filter the database" style="min-width: auto; max-width: auto"}
::: {#filterScript .codeDisplayer}
```{r}
#| label: filterScript
#| code-summary: This would execute if the if-else conditions were met to filter the db/data.db database table
#| file: "filterDatabase.R"
#| eval: false
```
:::
:::
:::

::: {.d-flex .justify-content-center}
::: {.btn .btn-secondary type="button" data-bs-toggle="offcanvas" data-bs-target="#offcanvas33" aria-controls="offcanvas"}
```{=html}
<i class="bi bi-code-slash" style="font-size: .75em; color: cornflowerblue;"></i>
```
:::
:::

::: {#offcanvas33 .offcanvas .offcanvas-start tabindex="-1" aria-labelledby="offcanvas" style="width: auto"}
::: offcanvas-header
::: {.h5 .offcanvas-title}
Filter Database
:::

::: {.btn-close type="button" data-bs-dismiss="offcanvas" ariaLabel="Close"}
:::
:::

::: offcanvas-body
::: flex-code
```{r}
#| label: filtering db
#| code-summary: First, if you happen to be re-using this code - this is so you do not have to re-download or re-filter after making further adjustments.

tblPath <- "db/data.db"
dupelessPath <- "db/dupeless.db"
tblPath_fltrd <- "db/data_fltrd.db"

if (exists("dbconn") == FALSE && dir.exists("db") == TRUE) {
    dbconn <- DBI::dbConnect(
        duckdb::duckdb(),
        dbdir = tblPath,
        read_only = FALSE,
        check_from = FALSE
    )
}

if (duckdb::dbExistsTable(dbconn,
                          "tblPath_fltrd") == FALSE) {
    source("filterDatabase.R")
    filterDatabase()
}
```
:::
:::
:::

# Exploratory Analysis

::: {.column-body .mb-2}
## Generating Frequency Tables {#sec-writeFreqs}

The rationale for frequency tables is to gain quick insights into the data. It is taking a methodical approach that, while simple, can create a crucial pathway towards understanding the bigger picture. Many of these tables are used in the tabset section, @sec-freqAnalysis.
:::

::: {.d-flex .justify-content-center .mb-3}
::: {.btn .btn-secondary type="button" data-bs-toggle="offcanvas" data-bs-target="#offcanvas10" aria-controls="offcanvas"}
```{=html}
<i class="bi bi-code-slash" style="font-size: .75em; color: cornflowerblue;"></i>
```
:::
:::

::: {#offcanvas10 .offcanvas .offcanvas-end tabindex="-1" aria-labelledby="offcanvas" style="width: auto"}
::: offcanvas-header
::: {.h5 .offcanvas-title}
Frequency Tables (other code)
:::

::: {.btn-close type="button" data-bs-dismiss="offcanvas" ariaLabel="Close"}
:::
:::

::: offcanvas-body
::: flex-code
```{r}
#| label: frequencyWrites_totals
#| code-summary: First, write the totals frequency tables to database.

# For the membership frequency
dplyr::tbl(dbconn,
           tblPath_fltrd,
           check_from = FALSE) |>
    dplyr::select(member_casual) |>
    dplyr::group_by(member_casual) |>
    dplyr::summarize(n = dplyr::n()) |>
    dplyr::collect() |>
    duckdb::dbWriteTable(conn = dbconn,
                         name = "db/freq_member.db",
                         overwrite = TRUE,
                         check_from = FALSE)

# For the rideable types.
dplyr::tbl(dbconn,
           tblPath_fltrd,
           check_from = FALSE) |>
    dplyr::select(rideable_type) |>
    dplyr::group_by(rideable_type) |>
    dplyr::summarize(n = dplyr::n()) |>
    dplyr::collect() |>
    duckdb::dbWriteTable(conn = dbconn,
                         name = "db/freq_rTypes.db",
                         overwrite = TRUE,
                         check_from = FALSE)

# For the miles
dplyr::tbl(dbconn,
           tblPath_fltrd,
           check_from = FALSE) |>
    dplyr::select(miles) |>
    dplyr::collect() |>
    dplyr::mutate(miles = dplyr::case_when(
        miles >= 1 ~ round(miles,
                           digits = 0),
        miles < 1 ~ round(signif(miles, 3),
                          digits = 1)
    )) |>
    dplyr::group_by(miles) |>
    dplyr::summarize(n = dplyr::n()) |>
    dplyr::arrange(miles) |>
    duckdb::dbWriteTable(
        conn = dbconn,
        name = "db/freq_miles.db",
        check_from = FALSE,
        overwrite = TRUE)

# For the mph
dplyr::tbl(dbconn,
           tblPath_fltrd,
           check_from = FALSE) |>
    dplyr::select(mph) |>
    dplyr::mutate(mph = round(mph, digits = 0)) |>
    dplyr::group_by(mph) |>
    dplyr::summarize(n = dplyr::n()) |>
    dplyr::collect() |>
    dplyr::arrange(mph) |>
    duckdb::dbWriteTable(conn = dbconn,
                         name = "db/freq_mph.db",
                         check_from = FALSE,
                         overwrite = TRUE)

# For the week days
dplyr::tbl(dbconn,
           tblPath_fltrd,
           check_from = FALSE) |>
    dplyr::select(started_at) |>
    dplyr::mutate(wkday = lubridate::wday(started_at)) |>
    dplyr::group_by(wkday) |>
    dplyr::summarize(n = dplyr::n()) |>
    dplyr::arrange(wkday) |>
    dplyr::collect() |>
    dplyr::mutate(wkday = c("Sun",
                            "Mon",
                            "Tue",
                            "Wed",
                            "Thu",
                            "Fri",
                            "Sat"),
                  wkday = forcats::as_factor(wkday),
                  wkday = forcats::fct_inorder(wkday)) |>
    duckdb::dbWriteTable(conn = dbconn,
                         name = "db/freq_wkDay.db",
                         check_from = FALSE,
                         overwrite = TRUE)

# For the months.
dplyr::tbl(dbconn,
           tblPath_fltrd,
           check_from = FALSE) |>
    dplyr::select(started_at) |>
    dplyr::mutate(months = lubridate::month(started_at,
                                            label = FALSE,
                                            abbr = TRUE
                                            )) |>
    dplyr::group_by(months) |>
    dplyr::summarize(n = dplyr::n()) |>
    dplyr::collect() |>
    dplyr::arrange(months) |>
    dplyr::mutate(months = c(month.abb),
                  months = forcats::as_factor(months),
                  months = forcats::fct_inorder(months)) |>
    duckdb::dbWriteTable(conn = dbconn,
                         name = "db/freq_month.db",
                         check_from = FALSE,
                         overwrite = TRUE)

# For the trip times.
dplyr::tbl(dbconn,
           tblPath_fltrd) |>
    dplyr::mutate(trip_time = round(trip_time,
                                    digits = 0)) |>
    dplyr::group_by(trip_time) |>
    dplyr::summarize(n = dplyr::n()) |>
    dplyr::arrange(trip_time) |>
    dplyr::collect() |>
    duckdb::dbWriteTable(conn = dbconn,
                         name = "db/freq_tripTime.db",
                         check_from = FALSE,
                         overwrite = TRUE)

# For the start station names
dplyr::tbl(dbconn,
           tblPath_fltrd) |>
    dplyr::select(start_station_name) |>
    dplyr::group_by(start_station_name) |>
    dplyr::summarize(n = dplyr::n()) |>
    dplyr::arrange(start_station_name) |>
    dplyr::collect() |>
    duckdb::dbWriteTable(conn = dbconn,
                         name = "db/freq_startNames.db",
                         check_from = FALSE,
                         overwrite = TRUE)


# For the station name pairs.
dplyr::tbl(dbconn,
           tblPath_fltrd) |>
    dplyr::select(start_station_name,
                  end_station_name) |>
    dplyr::group_by(start_station_name,
                    end_station_name) |>
    dplyr::summarize(n = dplyr::n()) |>
    dplyr::arrange(start_station_name) |>
    dplyr::collect() |>
    duckdb::dbWriteTable(conn = dbconn,
                         name = "db/freq_pairStations.db",
                         check_from = FALSE,
                         overwrite = TRUE)

# for the hours
dplyr::tbl(dbconn,
           tblPath_fltrd,
           check_from = FALSE) |>
    dplyr::select(started_at) |>
    dplyr::mutate("hour" = lubridate::hour(started_at)) |>
    dplyr::group_by(hour) |>
    dplyr::summarise("Total_Riders" = dplyr::n()) |> #or count?
    dplyr::arrange(hour) |>
    dplyr::collect() |>
    dplyr::mutate("hour" = hms::hms(hours = hour),
                  "hour" = format(strptime(hour, format = "%H"), "%r"),
                  "index" = seq(1:24)) |>
    duckdb::dbWriteTable(conn = dbconn,
                         name = "db/freq_hours.db",
                         check_from = FALSE,
                         overwrite = TRUE)

```

```{r}
#| label: frequencyWrites_comparisons
#| code-summary: Then, write all of the frequency comparison tables to the database.

# For the rideable type comparison
dplyr::tbl(dbconn,
           tblPath_fltrd,
           check_from = FALSE) |>
    dplyr::select(member_casual,
                  rideable_type) |>
    dplyr::group_by(rideable_type,
                    member_casual) |>
    dplyr::summarize(n = dplyr::n()) |>
    dplyr::collect() |>
    duckdb::dbWriteTable(conn = dbconn,
                         name = "db/freqCompare_rType.db",
                         overwrite = TRUE,
                         check_from = FALSE)

# For the miles comparison
dplyr::tbl(dbconn,
           tblPath_fltrd,
           check_from = FALSE) |>
    dplyr::select(member_casual,
                  miles) |>
    dplyr::collect() |>
    dplyr::mutate(miles = dplyr::case_when(
        miles >= 1 ~ round(miles,
                           digits = 0),
        miles < 1 ~ round(signif(miles, 3),
                          digits = 1)
    )) |>
    dplyr::group_by(miles,
                    member_casual) |>
    dplyr::summarize(n = dplyr::n()) |>
    dplyr::arrange(miles) |>
    duckdb::dbWriteTable(
        conn = dbconn,
        name = "db/freqCompare_miles.db",
        check_from = FALSE,
        overwrite = TRUE)

# For the mph comparison
dplyr::tbl(dbconn,
           tblPath_fltrd,
           check_from = FALSE) |>
    dplyr::select(mph,
                  member_casual) |>
    dplyr::mutate(mph = round(mph, digits = 0)) |>
    dplyr::group_by(member_casual,
                    mph) |>
    dplyr::summarize(n = dplyr::n()) |>
    dplyr::collect() |>
    dplyr::arrange(mph) |>
    duckdb::dbWriteTable(conn = dbconn,
                         name = "db/freqCompare_mph.db",
                         check_from = FALSE,
                         overwrite = TRUE)

# For the week days  comparison
dplyr::tbl(dbconn,
           tblPath_fltrd,
           check_from = FALSE) |>
    dplyr::select(member_casual,
                  started_at) |>
    dplyr::mutate(wkday = lubridate::wday(started_at)) |>
    dplyr::group_by(member_casual,
                    wkday) |>
    dplyr::summarize(n = dplyr::n()) |>
    dplyr::arrange(wkday) |>
    dplyr::collect() |>
    dplyr::mutate(wkday = c("Sun",
                            "Mon",
                            "Tue",
                            "Wed",
                            "Thu",
                            "Fri",
                            "Sat"),
                  wkday = forcats::as_factor(wkday),
                  wkday = forcats::fct_inorder(wkday)) |>
    duckdb::dbWriteTable(conn = dbconn,
                         name = "db/freqCompare_wkDay.db",
                         check_from = FALSE,
                         overwrite = TRUE)

# For the months comparison
dplyr::tbl(dbconn,
           tblPath_fltrd,
           check_from = FALSE) |>
    dplyr::select(member_casual,
                  started_at) |>
    dplyr::mutate(months = lubridate::month(started_at,
                                            label = FALSE,
                                            abbr = TRUE)) |>
    dplyr::group_by(member_casual,
                    months) |>
    dplyr::summarize(n = dplyr::n()) |>
    dplyr::collect() |>
    dplyr::arrange(months) |>
    dplyr::mutate(months = c(month.abb),
                  months = forcats::as_factor(months),
                  months = forcats::fct_inorder(months)) |>
    duckdb::dbWriteTable(conn = dbconn,
                         name = "db/freqCompare_month.db",
                         check_from = FALSE,
                         overwrite = TRUE)


# For the trip times comparison
dplyr::tbl(dbconn,
           tblPath_fltrd) |>
    dplyr::select(member_casual,
                  trip_time) |>
    dplyr::mutate(trip_time = round(trip_time,
                                    digits = 0)) |>
    dplyr::group_by(member_casual,
                    trip_time) |>
    dplyr::summarize(n = dplyr::n()) |>
    dplyr::arrange(trip_time) |>
    dplyr::collect() |>
    duckdb::dbWriteTable(conn = dbconn,
                         name = "db/freqCompare_tripTime.db",
                         check_from = FALSE,
                         overwrite = TRUE)

# For the start station names comparison
dplyr::tbl(dbconn,
           tblPath_fltrd) |>
    dplyr::select(member_casual,
                  start_station_name) |>
    dplyr::group_by(member_casual,
                    start_station_name) |>
    dplyr::summarize(n = dplyr::n()) |>
    dplyr::arrange(start_station_name) |>
    dplyr::collect() |>
    duckdb::dbWriteTable(conn = dbconn,
                         name = "db/freqCompare_startNames.db",
                         check_from = FALSE,
                         overwrite = TRUE)

# For the station name pairs comparison
dplyr::tbl(dbconn,
           tblPath_fltrd) |>
    dplyr::select(member_casual,
                  start_station_name,
                  end_station_name) |>
    dplyr::group_by(start_station_name,
                    end_station_name,
                    member_casual) |>
    dplyr::summarize(n = dplyr::n()) |>
    dplyr::arrange(start_station_name,
                   end_station_name) |>
    dplyr::collect() |>
    duckdb::dbWriteTable(conn = dbconn,
                         name = "db/freqCompare_pairStations.db",
                         check_from = FALSE,
                         overwrite = TRUE)

dplyr::tbl(dbconn,
           tblPath_fltrd,
           check_from = FALSE) |>
    dplyr::select(started_at, member_casual) |>
    dplyr::mutate("hour" = lubridate::hour(started_at)) |>
    dplyr::group_by(member_casual, hour) |>
    dplyr::summarise("Total_Riders" = dplyr::n()) |> #or count?
    dplyr::arrange(hour, member_casual) |>
    dplyr::collect() |>
    dplyr::mutate("hour" = hms::hms(hours = hour),
                  "hour" = format(strptime(hour, format = "%H"), "%r"),
                  "index" = seq(1:24)) |>
    duckdb::dbWriteTable(conn = dbconn,
                         name = "db/freqCompare_hours.db",
                         check_from = FALSE,
                         overwrite = TRUE)
```
:::
:::
:::

## Table Analysis {#sec-freqAnalysis}

::: column-screen
::: {.d-flex .justify-content-center}

::: {.panel-tabset .shadow-sm}

## Membership

::: article
::: section
::: {.d-flex .justify-content-around .align-content-stretch}
::: {.p-3 .align-self-center .align-content-stretch .auto-fit}
### Overall Member to Casual Count 
:::

::: divBox
:::

::: {.p-3 .align-self-center}
@tbl-memberTotals gives the total count of trips taken by members and casuals. The rest of the tabs in this section will give total counts along with group counts by membership status.
:::
:::
:::

------------------------------------------------------------------------

::: {.d-flex .align-content-stretch}
::: p-3
```{r}
#| label: tbl-memberTotals
#| tbl-cap: Total Member Frequency


dplyr::tbl(dbconn, "db/freq_member.db") |>
gt::gt() |>
gt::tab_header(title = "Subscriber Frequency", subtitle = "Annual and casual rider trip counts") |>
gt::fmt_number(decimals = 0) |>
gt::tab_options(
table.background.color = 'transparent',
table.font.color = "SeaShell",
table_body.vlines.color = "gray20",
table_body.hlines.color = "gray20",
column_labels.hidden = TRUE
)

members_totalSummary <- dplyr::tbl(dbconn, tblPath_fltrd) |>
dplyr::select(member_casual) |>
dplyr::collect() |>
gtsummary::tbl_summary() |>
gtsummary::as_gt() |>
gt::tab_options(
table.background.color = 'transparent',
table.font.color = "SeaShell",
table_body.vlines.color = "gray20",
table_body.hlines.color = "gray20")
```
:::

::: p-3
```{r}
#| label: fig-totalmemberFrequency
#| fig-cap: Total Member Frequency

member_freqTbl <- dplyr::tbl(dbconn, "db/freq_member.db") |>
dplyr::collect()

member_freqTbl |>
ggplot2::ggplot(mapping = ggplot2::aes(x = member_casual, y = n, fill = n)) +
ggplot2::geom_col(show.legend = FALSE) +
ggplot2::labs(title = "Membership Frequency", subtitle = "Trips taken by annual subscribers vs non-subscribers") +
ggplot2::scale_fill_distiller(palette = "YlOrRd") +
ggplot2::theme(
panel.background = ggplot2::element_rect(fill = "#222222", color = NA),
plot.background = ggplot2::element_rect(fill = "#222222", color = NA),
text = ggplot2::element_text(color = "seashell"),
panel.grid = ggplot2::element_blank(),
axis.title.x = ggplot2::element_text(margin = grid::unit(c(5, 5, 5, 5), "mm")),
axis.title.y = ggplot2::element_text(margin = grid::unit(c(5, 5, 5, 5), "mm")),
axis.text.x = ggplot2::element_text(color = "Snow", margin = grid::unit(c(1, 1, 1, 1), "mm")),
axis.text.y = ggplot2::element_text(color = "Snow", margin = grid::unit(c(2, 2, 2, 2), "mm")),
axis.ticks = ggplot2::element_line(color = "LavenderBlush"),
axis.ticks.y = ggplot2::element_blank(),
panel.grid.major.y = ggplot2::element_line(color = "grey30"))

```
:::
:::
:::

## Cycle Types

::: article
::: section
::: {.d-flex .align-content-stretch}
::: {.p-3 .align-self-center}
-   [Totals Summary](#total_types_freq)
    -   [table](#tbl-ctypeTotals)
    -   [plot](#fig-ctypeTotal)
-   [Membership Summary](#group_types_freq)
    -   [table](#tbl-ctypeCompare)
    -   [plot](#fig-ctypeTotals)
-   [Test Association](#sec-chiTypes)
    -   [table](#tbl-chiTypes)
:::

::: divBox
:::

::: {.p-1 .align-self-center}
In @tbl-ctypeTotals and @fig-ctypeTotals, the total trips taken on conventional bicycles and electric bicycles are compared. Clearly, electric bicycles are not used as much as conventional.

Moving to @tbl-ctypeCompare and @fig-ctypeCompare, the frequency of trips taken is split into groups of membership status. There is a large disparity not only between the scale of trips taken between annual subscribers and casual users, but also within the the group of subscribers themselves. While there is a small difference between trips taken by casual members on conventional compared to electric, that said difference is more pronounced in the annual subscriber group.

With $p < 0.05$, there appears to be a strong association between members and casuals with regards to the type of bicycles people are likely to ride. @tbl-chiTypes
:::
:::
:::

------------------------------------------------------------------------

### Totals Summary {#total_types_freq}

::: {.d-flex .align-content-stretch}
::: p-3
```{r}
#| label: tbl-ctypeTotals
#| tbl-cap: Cycle Type Total Frequency

dplyr::tbl(dbconn, "db/freq_rTypes.db") |>
gt::gt() |>
gt::tab_header(title = "Bicycle Type Frequency", subtitle = "Counts trips taken by cycle type") |>
gt::fmt_number(decimals = 0) |>
gt::tab_options(
table.background.color = 'transparent',
table.font.color = "SeaShell",
table_body.vlines.color = "gray20",
table_body.hlines.color = "gray20",
column_labels.hidden = TRUE
)

```
:::

::: p-3
```{r}
#| label: fig-ctypeTotals
#| fig-cap: Cycle Type Total Frequency 

ridetype_freqTbl <- dplyr::tbl(dbconn, "db/freq_rTypes.db") |>
dplyr::collect()

ridetype_freqTbl |>
ggplot2::ggplot(mapping = ggplot2::aes(x = rideable_type, y = n, fill = n)) +
ggplot2::geom_col(show.legend = FALSE) +
ggplot2::scale_fill_distiller(palette = "YlOrRd") +
ggplot2::labs(title = "Cycle Type Frequency", subtitle = "Trips taken per cycle type") +
ggplot2::theme(
panel.background = ggplot2::element_rect(fill = "#222222", color = NA),
plot.background = ggplot2::element_rect(fill = "#222222", color = NA),
text = ggplot2::element_text(color = "seashell"),
panel.grid = ggplot2::element_blank(),
axis.title.x = ggplot2::element_text(margin = grid::unit(c(5, 5, 5, 5), "mm")),
axis.title.y = ggplot2::element_text(margin = grid::unit(c(5, 5, 5, 5), "mm")),
axis.text.x = ggplot2::element_text(color = "Snow", margin = grid::unit(c(1, 1, 1, 1), "mm")),
axis.text.y = ggplot2::element_text(color = "Snow", margin = grid::unit(c(2, 2, 2, 2), "mm")),
axis.ticks = ggplot2::element_line(color = "LavenderBlush"),
axis.ticks.y = ggplot2::element_blank(),
panel.grid.major.y = ggplot2::element_line(color = "grey30")
)
```
:::
:::

------------------------------------------------------------------------

### Membership Summary {#group_types_freq}

::: {.d-flex .align-content-stretch}
::: p-3
```{r}
#| label: tbl-ctypeCompare
#| tbl-cap: Cycle Type Group Frequency


ctype_tbl <- dplyr::tbl(dbconn, "db/freqCompare_rType.db") |>
gt::gt(groupname_col = "rideable_type", row_group_as_column = TRUE) |>
gt::tab_header(title = "Bicycle Type to Membership Frequency", subtitle = "Grouped by sub. status") |>
gt::fmt_number(decimals = 0) |>
gt::tab_options(
table.background.color = 'transparent',
table.font.color = "SeaShell",
table_body.vlines.color = "gray20",
table_body.hlines.color = "gray20",
column_labels.hidden = TRUE)


ctype_tbl

```
:::

::: p-3
```{r}
#| label: fig-ctypeCompare
#| fig-cap: Cycle Type Group Frequency

dplyr::tbl(dbconn, "db/freqCompare_rType.db") |>
ggplot2::ggplot(mapping = ggplot2::aes(x = rideable_type, y = n, fill = member_casual)) +
ggplot2::geom_col(show.legend = TRUE, position = "dodge") +
ggplot2::scale_fill_brewer(palette = "Paired", name = "Subscriber Status") +
ggplot2::labs(title = "Cycle Type to Membership Frequency", subtitle = "Compare trips taken by cycle type to membership status") +
ggplot2::theme(
panel.background = ggplot2::element_rect(fill = "#222222", color = NA),
plot.background = ggplot2::element_rect(fill = "#222222", color = NA),
text = ggplot2::element_text(color = "seashell"),
panel.grid = ggplot2::element_blank(),
axis.title.x = ggplot2::element_text(margin = grid::unit(c(5, 5, 5, 5), "mm")),
axis.title.y = ggplot2::element_text(margin = grid::unit(c(5, 5, 5, 5), "mm")),
axis.text.x = ggplot2::element_text(color = "Snow", margin = grid::unit(c(1, 1, 1, 1), "mm")),
axis.text.y = ggplot2::element_text(color = "Snow", margin = grid::unit(c(2, 2, 2, 2), "mm")),
axis.ticks = ggplot2::element_line(color = "LavenderBlush"),
axis.ticks.y = ggplot2::element_blank(),
panel.grid.major.y = ggplot2::element_line(color = "grey30"),
legend.background = ggplot2::element_rect(fill = "#222222")
)

```
:::
:::

------------------------------------------------------------------------

### Testing the association between membership and bicycle type {#sec-chiTypes}

```{r}
#| label: tbl-chiTypes

ctype_compareSummary <- dplyr::tbl(dbconn, tblPath_fltrd) |>
dplyr::select(rideable_type, member_casual) |>
dplyr::collect() |>
gtsummary::tbl_summary(by = member_casual, label = list(rideable_type = "Bicycle Type", member_casual = "Membership")) |>
gtsummary::add_p()


ctype_compareSummary |>
gtsummary::as_gt() |>
gt::tab_options(
table.background.color = 'transparent',
table.font.color = "SeaShell",
table_body.vlines.color = "gray20",
table_body.hlines.color = "gray20")

```
:::

## Month

::: article
::: section
::: {.d-flex .align-content-stretch}
::: {.p-3 .align-self-center}
-   [Totals Summary](#total_month_freq)
    -   [table](#tbl-monthTotals)
    -   [plot](#fig-monthTotals)
-   [Membership Summary](#group_month_freq)
    -   [table](#tbl-monthGroup)
    -   [plot](#fig-monthGroup)
-   [Test Association](#sec-monthChi)
    -   [table](#tbl-chiMonths)
:::

::: divBox
:::

::: {.p-1 .align-self-center}
Looking at @tbl-monthTotals and @fig-monthTotals, the warmer months appear to coincide with higher trip frequency, in total.

In @tbl-monthCompare and @fig-monthCompare, trip frequency in both groups are impacted by the seasons. Although, it would appear that trip frequency of subscribers fluctuates less than for casuals. The disparity in frequency change is more apparent in the comparison of winter to summer months between member groups.

Given $p < 0.05$, it is likely that membership status is associated with a given member's or non-member's use of the service during a particular month or season. @tbl-chiMonths
:::
:::
:::

------------------------------------------------------------------------

### Totals Summary {#total_month_freq}

::: d-flex
::: p-3
```{r}
#| label: tbl-monthTotals
#| tbl-cap: Month Total Frequency

dplyr::tbl(dbconn, "db/freq_month.db") |>
gt::gt() |>
gt::tab_header(title = "Monthly Trips Frequency", subtitle = "Tallies trips taken by month") |>
gt::fmt_number(decimals = 0) |>
gt::tab_options(
table.background.color = 'transparent',
table.font.color = "SeaShell",
table_body.vlines.color = "gray20",
table_body.hlines.color = "gray20",
column_labels.hidden = TRUE
)
```
:::

::: p-3
```{r}
#| label: fig-monthTotals
#| fig-cap: Month Total Frequency


monthlyTable <- dplyr::tbl(dbconn, "db/freq_month.db") |>
dplyr::collect()
    
monthlyTable |>
ggplot2::ggplot(mapping = ggplot2::aes(x = months, y = n, fill = n)) +
ggplot2::geom_col(show.legend = FALSE) +
ggplot2::labs(title = "Monthly Trip Frequency", subtitle = "A total count of trips taken by month") +
ggplot2::scale_fill_distiller(palette = "YlOrRd") +
ggplot2::theme(
panel.background = ggplot2::element_rect(fill = "#222222", color = NA),
plot.background = ggplot2::element_rect(fill = "#222222", color = NA),
text = ggplot2::element_text(color = "seashell"),
panel.grid = ggplot2::element_blank(),
axis.title.x = ggplot2::element_text(margin = grid::unit(c(5, 5, 5, 5), "mm")),
axis.title.y = ggplot2::element_text(margin = grid::unit(c(5, 5, 5, 5), "mm")),
axis.text.x = ggplot2::element_text(color = "Snow", margin = grid::unit(c(1, 1, 1, 1), "mm")),
axis.text.y = ggplot2::element_text(color = "Snow", margin = grid::unit(c(2, 2, 2, 2), "mm")),
axis.ticks = ggplot2::element_line(color = "LavenderBlush"),
axis.ticks.y = ggplot2::element_blank(),
panel.grid.major.y = ggplot2::element_line(color = "grey30")
)

```
:::
:::

------------------------------------------------------------------------

### Membership Summary {#group_month_frequency}

::: d-flex
::: {.p-3 .tableScroller}
```{r}
#| label: tbl-monthCompare
#| tbl-cap: Month Group Frequency


dplyr::tbl(dbconn, "db/freqCompare_month.db") |>
gt::gt(groupname_col = "months", row_group_as_column = TRUE) |>
gt::tab_header(title = "Month to Membership Frequency", subtitle = "Grouped by sub status") |>
gt::fmt_number(decimals = 0) |>
gt::cols_label(months = "Month", member_casual = "Membership") |>
gt::tab_options(
table.background.color = 'transparent',
table.font.color = "SeaShell",
table_body.vlines.color = "gray20",
table_body.hlines.color = "gray20",
column_labels.hidden = FALSE
)

```
:::

::: ml-5
```{r}
#| label: fig-monthCompare
#| fig-cap: Month Group Frequency

dplyr::tbl(dbconn, "db/freqCompare_month.db") |>
dplyr::collect() |>
ggplot2::ggplot(mapping = ggplot2::aes(x = months, y = n, fill = n)) +
ggplot2::geom_col(show.legend = TRUE) +
ggplot2::facet_grid(rows = "member_casual") +
ggplot2::scale_fill_distiller(palette = "YlGnBu") +
ggplot2::labs(title = "Month to Membership Frequency", subtitle = "Grouped by sub status", x = "Month", y = "Trips") +
ggplot2::theme(
panel.background = ggplot2::element_rect(fill = "#222222", color = NA),
plot.background = ggplot2::element_rect(fill = "#222222", color = NA),
text = ggplot2::element_text(color = "seashell"),
panel.grid = ggplot2::element_blank(),
axis.title.x = ggplot2::element_text(margin = grid::unit(c(5, 5, 5, 5), "mm")),
axis.title.y = ggplot2::element_text(margin = grid::unit(c(5, 5, 5, 5), "mm")),
axis.text.x = ggplot2::element_text(color = "Snow", margin = grid::unit(c(1, 1, 1, 1), "mm")),
axis.text.y = ggplot2::element_text(color = "Snow", margin = grid::unit(c(2, 2, 2, 2), "mm")),
axis.ticks = ggplot2::element_line(color = "LavenderBlush"),
axis.ticks.y = ggplot2::element_blank(),
panel.grid.major.y = ggplot2::element_line(color = "grey30"),
legend.background = ggplot2::element_rect(fill = "#222222")
)

```
:::
:::

------------------------------------------------------------------------

### Testing the association between membership and month {#sec-monthChi}

```{r}
#| label: tbl-chiMonths

month_tbl <- dplyr::tbl(dbconn, tblPath_fltrd, check_from = FALSE) |>
dplyr::select(member_casual, started_at) |>
dplyr::mutate(months = lubridate::month(started_at, label = TRUE, abbr = TRUE)) |>
dplyr::collect() |>
dplyr::mutate(months = forcats::as_factor(months), months = forcats::fct_inorder(months))

# For finding chi-square p-value in a nicely formatted table
month_tbl |>
dplyr::select(months, member_casual) |>
gtsummary::tbl_summary(by = member_casual, label = list(months = "Month", member_casual = "Membership")) |>
gtsummary::add_p() |>
gtsummary::as_gt() |>
gt::tab_options(
table.background.color = 'transparent',
table.font.color = "SeaShell",
table_body.vlines.color = "gray20",
table_body.hlines.color = "gray20")

```
:::

## Day

::: article
::: section
::: {.d-flex .align-content-stretch}
::: {.p-2 .align-self-center}
-   [Totals Summary](#total_day_freq)
    -   [table](#tbl-wkdayTotals)
    -   [plot](#fig-wkdayTotals)
-   [Membership Summary](#group_day_freq)
    -   [table](#tbl-wkdayCompare)
    -   [plot](#fig-wkdayCompare)
-   [Test Association](#sec-chiDays)
    -   [table](#tbl-chiDays)
:::

::: divBox
:::

::: {.p-1 .align-self-center}
In @tbl-wkdayTotals and @fig-wkdayTotals, there appears to be more trips taken in total between Tuesday through Saturday than Sunday through Monday.

The trend is more complicated in the weekday comparison groups seen in @tbl-wkdayCompare and @fig-wkdayCompare. Trips taken by the casual group rises towards the weekend and dips on days corresponding to days when members are taking more trips. When members are less active, casual riders are more active.

Given, $p < 0.05$, the likelihood of using the service on a particular day depends on membership status. @tbl-chiDays
:::
:::
:::

------------------------------------------------------------------------

### Totals Summary {#total_day_freq}

::: d-flex
::: p-3
```{r}
#| label: tbl-wkdayTotals
#| tbl-cap: Weekday Total Frequency



dplyr::tbl(dbconn, "db/freq_wkday.db") |>
gt::gt() |>
gt::tab_header(title = "Weekday Trip Frequency", subtitle = "Tallies trips taken by the day of the week") |>
gt::fmt_number(decimals = 0) |>
gt::tab_options(
table.background.color = 'transparent',
table.font.color = "SeaShell",
table_body.vlines.color = "gray20",
table_body.hlines.color = "gray20",
column_labels.hidden = TRUE
)
```
:::

::: p-3
```{r}
#| label: fig-wkdayTotals
#| fig-cap: Weekday Totals Frequency

weekdayTable <- dplyr::tbl(dbconn,
           "db/freq_wkday.db") |>
    dplyr::collect()
    
weekdayTable |>
ggplot2::ggplot(mapping = ggplot2::aes(x = wkday, y = n, fill = n)) +
ggplot2::coord_cartesian(ylim = c(4 * 10 ^ 5, NA)) +
ggplot2::geom_col(show.legend = FALSE) +
ggplot2::labs(title = "Weekday Trip Frequency", subtitle = "Trips by day of week") +
ggplot2::scale_fill_distiller(palette = "YlOrRd") +
ggplot2::theme(
panel.background = ggplot2::element_rect(fill = "#222222", color = NA),
plot.background = ggplot2::element_rect(fill = "#222222", color = NA),
text = ggplot2::element_text(color = "seashell"),
panel.grid = ggplot2::element_blank(),
axis.title.x = ggplot2::element_text(margin = grid::unit(c(5, 5, 5, 5), "mm")),
axis.title.y = ggplot2::element_text(margin = grid::unit(c(5, 5, 5, 5), "mm")),
axis.text.x = ggplot2::element_text(color = "Snow", margin = grid::unit(c(1, 1, 1, 1), "mm")),
axis.text.y = ggplot2::element_text(color = "Snow", margin = grid::unit(c(2, 2, 2, 2), "mm")),
axis.ticks = ggplot2::element_line(color = "LavenderBlush"),
axis.ticks.y = ggplot2::element_blank(),
panel.grid.major.y = ggplot2::element_line(color = "grey30")
)

```
:::
:::

------------------------------------------------------------------------

### Membership Summary {#group_day_freq}

::: d-flex
::: p-3
```{r}
#| label: tbl-wkdayCompare
#| tbl-cap: Weekday Group Frequency

dplyr::tbl(dbconn, "db/freqCompare_wkday.db") |>
gt::gt(groupname_col = "wkday", row_group_as_column = TRUE) |>
gt::tab_header(title = "Day to Membership Frequency") |>
gt::cols_label(n = "Trips", member_casual = "Membership") |>
gt::fmt_number(decimals = 0) |>
gt::tab_options(
table.background.color = 'transparent',
table.font.color = "SeaShell",
table_body.vlines.color = "gray20",
table_body.hlines.color = "gray20",
column_labels.hidden = FALSE)

```
:::

::: {.ml-2 .align-self-center}
```{r}
#| label: fig-wkdayCompare
#| fig-cap: Weekday Group Frequency

dplyr::tbl(dbconn, "db/freqCompare_wkday.db") |>
ggplot2::ggplot(mapping = ggplot2::aes(x = wkday, y = n, fill = n)) +
ggplot2::geom_col(show.legend = TRUE) +
ggplot2::facet_grid(rows = "member_casual") +
ggplot2::scale_fill_distiller(palette = "YlGnBu", 
name = "Subscriber Status") +
ggplot2::labs(title = "Weekday to Membership Frequency", subtitle = "Grouped by sub status", x = "Day", y = "Trips") +
ggplot2::theme(
panel.background = ggplot2::element_rect(fill = "#222222", color = NA),
plot.background = ggplot2::element_rect(fill = "#222222", color = NA),
text = ggplot2::element_text(color = "seashell"),
panel.grid = ggplot2::element_blank(),
axis.title.x = ggplot2::element_text(margin = grid::unit(c(5, 5, 5, 5), "mm")),
axis.title.y = ggplot2::element_text(margin = grid::unit(c(5, 5, 5, 5), "mm")),
axis.text.x = ggplot2::element_text(color = "Snow", margin = grid::unit(c(1, 1, 1, 1), "mm")),
axis.text.y = ggplot2::element_text(color = "Snow", margin = grid::unit(c(2, 2, 2, 2), "mm")),
axis.ticks = ggplot2::element_line(color = "LavenderBlush"),
axis.ticks.y = ggplot2::element_blank(),
panel.grid.major.y = ggplot2::element_line(color = "grey30"),
legend.background = ggplot2::element_rect(fill = "#222222"))

```
:::
:::

------------------------------------------------------------------------

### Testing the association between day and membership {#sec-chiDays}

```{r}
#| label: tbl-chiDays

# For the week days  comparison
day_tbl <- dplyr::tbl(dbconn, tblPath_fltrd, check_from = FALSE) |>
dplyr::select(member_casual, started_at) |>
dplyr::mutate(wkday = lubridate::wday(started_at, label = TRUE, abbr = TRUE)) |>
dplyr::collect() |>
dplyr::mutate(wkday = forcats::as_factor(wkday),
wkday = forcats::fct_inorder(wkday))

day_tbl |>
dplyr::select(wkday, member_casual) |>
gtsummary::tbl_summary(by = member_casual, label = list(wkday = "Day", member_casual = "Membership")) |>
gtsummary::add_p() |>
gtsummary::as_gt() |>
gt::tab_options(
table.background.color = 'transparent',
table.font.color = "SeaShell",
table_body.vlines.color = "gray20",
table_body.hlines.color = "gray20")

```
:::

## Hour

::: article
::: section
::: {.d-flex .align-content-stretch}
::: {.p-3 .align-self-center}
-   [Totals Summary](#total_hour_freq)
    -   [table](#tbl-hourTotals)
    -   [plot](#fig-hourTotals)
-   [Membership Summary](#group_hour_freq)
    -   [table](#tbl-hourGroup)
    -   [plot](#fig-hourGroup)
-   [Test Association](#sec-chiHours)
    -   [table](#tbl-chiHours)
:::

::: divBox
:::

::: {.p-3 .align-self-center}
The overall trend follows the typical work day cycle where one would expect to see with spikes in the mornings and evenings. @tbl-hourTotals @fig-hourTotals

There is a noted discrepency between member and casual use during peak commute hours. Members have more notable spike during morning commute hours than casuals, which appears more flat throughout the day. @tbl-hourCompare @fig-hourCompare
:::
:::
:::

------------------------------------------------------------------------

### Totals Summary {#total_hour_freq}

::: {.d-flex .justify-content-around}
```{r}
#| label: simplifyHoursFormat
#| echo: false

hours_of_Riders <- dplyr::tbl(dbconn, "db/freq_hours.db") |>
dplyr::collect()

x <-
stringr::str_sub_all(hours_of_Riders[[1]], start = 1, end = 2) |>
as.character() |>
stringr::str_remove(pattern = "^0")


y <- 
stringr::str_sub(hours_of_Riders[[1]], start = -2, end = -1) |>
stringr::str_to_lower()

simpleTimes <- stringr::str_c(x, sep = " ", y)

hours_of_Riders[[1]] <- simpleTimes
```

::: {.p-3 .tableScroller}
```{r}
#| label: tbl-hourTotals
#| tbl-cap: Total freqeuncy by the hour of day

hours_of_Riders |>
dplyr::select(hour, Total_Riders) |>
gt::gt() |>
gt::tab_header(
title = "Hour Frequency", 
subtitle = "Counts trips taken by the hour of day"
) |>
gt::fmt_number(decimals = 0) |>
gt::tab_options(
table.background.color = 'transparent',
table.font.color = "SeaShell",
table_body.vlines.color = "gray20",
table_body.hlines.color = "gray20",
column_labels.hidden = TRUE
)
```
:::

::: {.p-3 .flex-grow-1}
```{r}
#| label: 'fig-hourTotals'
#| fig-cap: "Total frequency by hour of day."

hours_of_Riders |>
ggplot2::ggplot(
mapping = ggplot2::aes(
x = reorder(hour, .data$index),
y = Total_Riders,
fill = Total_Riders
)
) +
ggplot2::geom_col(show.legend = FALSE) +
#ggplot2::coord_radial(start = 2 * pi, inner.radius = .2) +
ggplot2::scale_fill_distiller(palette = "YlOrRd") +
ggplot2::scale_x_discrete(guide = ggplot2::guide_axis(n.dodge = 1, angle = 45)) +
ggplot2::labs(title = "Average Riders by the Hour of Day", x = "Hour", y = "Trips") +
ggplot2::theme(
panel.background = ggplot2::element_rect(fill = "#222222", color = NA),
plot.background = ggplot2::element_rect(fill = "#222222", color = NA),
text = ggplot2::element_text(color = "seashell"),
panel.grid = ggplot2::element_blank(),
axis.title.x = ggplot2::element_text(margin = grid::unit(c(5, 5, 5, 5), "mm")),
axis.title.y = ggplot2::element_text(margin = grid::unit(c(5, 5, 5, 5), "mm")),
axis.text.x = ggplot2::element_text(color = "Snow", margin = grid::unit(c(1, 1, 1, 1), "mm")),
axis.text.y = ggplot2::element_text(color = "Snow", margin = grid::unit(c(2, 2, 2, 2), "mm")),
axis.ticks = ggplot2::element_line(color = "LavenderBlush"),
axis.ticks.y = ggplot2::element_blank(),
panel.grid.major.y = ggplot2::element_line(color = "grey30")
)

```
:::
:::

------------------------------------------------------------------------

### Membership Summary

::: {.d-flex .justify-content-around .align-content-stretch}
::: {.p-3 .tableScroller}
```{r}
#| label: tbl-hourCompare
#| tbl-cap: Grouped hour frequency


hour_tbl <- 
dplyr::tbl(dbconn, "db/freqCompare_hours.db") |>
dplyr::collect() |>
dplyr::mutate(
hour = forcats::as_factor(hour), 
hour = forcats::fct_inorder(hour),
Total_Riders = as.integer(Total_Riders)
)

x <-
stringr::str_sub_all(hour_tbl[[2]], start = 1, end = 2) |>
as.character() |>
stringr::str_remove(pattern = "^0")


y <- 
stringr::str_sub(hour_tbl[[2]], start = -2, end = -1) |>
stringr::str_to_lower()

simpleTimes <- stringr::str_c(x, sep = " ", y)

hour_tbl[[2]] <- simpleTimes

hour_tbl <- hour_tbl |>
dplyr::mutate(
hour = forcats::as_factor(hour),
hour = forcats::fct_inorder(hour)
)

hour_tbl |>
dplyr::select(member_casual:Total_Riders) |>
gt::gt(
groupname_col = "hour", 
row_group_as_column = TRUE
) |>
gt::fmt_number(decimals = 0) |>
gt::tab_header(
title = "Hour to Membership Frequency",
subtitle = "Counts total trips by membership") |>
gt::tab_options(
table.background.color = 'transparent',
table.font.color = "SeaShell",
table_body.vlines.color = "gray20",
table_body.hlines.color = "gray20",
column_labels.hidden = TRUE
)

```
:::

::: {.p-3 .align-self-center}
```{r}
#| label: fig-hourCompare
#| fig-cap: Grouped hour frequency

hour_tbl |>
ggplot2::ggplot(ggplot2::aes(x = hour, y = Total_Riders, fill = Total_Riders)) +
ggplot2::geom_col(show.legend = TRUE) +
ggplot2::facet_grid(rows = "member_casual") +
ggplot2::scale_fill_distiller(palette = "YlGnBu", name = NULL) +
ggplot2::scale_x_discrete(guide = ggplot2::guide_axis(n.dodge = 1, angle = 45)) +
ggplot2::labs(title = "Hour to Membership Count", x = "Hour", y = "Trips") +
ggplot2::theme(
panel.background = ggplot2::element_rect(fill = "#222222", color = NA),
plot.background = ggplot2::element_rect(fill = "#222222", color = NA),
text = ggplot2::element_text(color = "seashell"),
panel.grid = ggplot2::element_blank(),
axis.title.x = ggplot2::element_text(margin = grid::unit(c(5, 5, 5, 5), "mm")),
axis.title.y = ggplot2::element_text(margin = grid::unit(c(5, 5, 5, 5), "mm")),
axis.text.x = ggplot2::element_text(color = "Snow", margin = grid::unit(c(1, 1, 1, 1), "mm")),
axis.text.y = ggplot2::element_text(color = "Snow", margin = grid::unit(c(2, 2, 2, 2), "mm")),
axis.ticks = ggplot2::element_line(color = "LavenderBlush"),
axis.ticks.y = ggplot2::element_blank(),
panel.grid.major.y = ggplot2::element_line(color = "grey30"),
legend.background = ggplot2::element_rect(fill = "#222222"),
panel.spacing = ggplot2::unit(4, "mm")
)

```
:::
:::

### Can the hour of the day predict membership? {#sec-chiHours}

```{r}
#| label: tbl-chiHours
#| tbl-cap: "Can the hour of the day correlate to a binary outcome, such as membership?"

hour_tbl <- dplyr::tbl(dbconn, tblPath_fltrd, check_from = FALSE) |>
dplyr::select(started_at, member_casual) |>
dplyr::mutate("hour" = lubridate::hour(started_at)) |>
dplyr::arrange(hour) |>
dplyr::collect() |>
dplyr::mutate(
hour = hms::hms(hours = hour),
# Need the 12 hour clock times
hour = format(strptime(hour, format = "%H"), "%r"),
hour = forcats::as_factor(hour),
hour = forcats::fct_inorder(hour)
)

x <-
stringr::str_sub_all(hour_tbl[[3]], start = 1, end = 2) |>
as.character() |>
stringr::str_remove(pattern = "^0")


y <- 
stringr::str_sub(hour_tbl[[3]], start = -2, end = -1) |>
stringr::str_to_lower()

simpleTimes <- stringr::str_c(x, sep = " ", y)

hour_tbl[[3]] <- simpleTimes


hour_tbl |>
dplyr::select(hour, member_casual) |>
gtsummary::tbl_summary(by = member_casual, label = list(hour = "Hour", member_casual = "Membership")) |>
gtsummary::add_p() |>
gtsummary::as_gt() |>
gt::tab_options(
table.background.color = 'transparent',
table.font.color = "SeaShell",
table_body.vlines.color = "gray20",
table_body.hlines.color = "gray20")

```



:::

## Miles

::: article
::: section
::: {.d-flex .align-content-stretch}
::: {.p-3 .align-self-center}
-   [Totals Summary](#total_miles_freq)
    -   [table](#tbl-milesTotals)
    -   [plot](#fig-milesTotals)
-   [Membership Summary](#group_miles_freq)
    -   [table](#tbl-milesCompare)
    -   [plot](#fig-milesCompare)
-   [Test Association](#sec-logMiles)
    -   [table](#tbl-logMiles)
:::

::: divBox
:::

::: {.p-1 .align-self-center}
The distance of most observed trips in @tbl-milesTotals and @fig-milesTotals fall in between 0.3 to 3 miles.

The groups comparison seen in @tbl-milesCompare and @fig-milesCompare show the same pattern. The casual and member differ mainly in overall scale of trips taken between the 0.3 and 3 mile trip distances.

$\beta_1 < 0$, members are less likely to ride as distance traveled in a given trip increases. So, members tend to take shorter trips compared to casual users. @tbl-milesLog
:::
:::
:::

::: br
:::

------------------------------------------------------------------------

### Totals Summary {#total_miles_freq}

::: {.d-flex .justify-content-around}
::: {.p-3 .tableScroller}
```{r}
#| label: tbl-milesTotals
#| tbl-cap: Miles Total Frequency

dplyr::tbl(dbconn, "db/freq_miles.db") |>
dplyr::arrange(miles) |>
dplyr::collect() |>
dplyr::mutate(
#n = n / 1000,
miles = forcats::as_factor(miles),
miles = forcats::fct_inorder(miles)
) |>
gt::gt() |>
gt::cols_label(miles = "Miles", n = "Trips") |>
gt::fmt_number(decimals = 0) |>
gt::tab_header(title = "Distance Frequency", subtitle = "Distance is measured in miles") |>
gt::tab_options(
table.background.color = 'transparent',
table.font.color = "SeaShell",
table_body.vlines.color = "gray20",
table_body.hlines.color = "gray20"
)
```
:::

::: p-3
```{r}
#| label: fig-milesTotals
#| fig-cap: Miles Total Frequency

dplyr::tbl(dbconn, "db/freq_miles.db") |>
dplyr::collect() |>
dplyr::mutate(
n = n / 1000,
miles = forcats::as_factor(miles),
miles = forcats::fct_inorder(miles)
) |>
dplyr::rename("Trips (in thousands)" = n, "Miles" = miles) |>
ggplot2::ggplot(mapping = ggplot2::aes(x = Miles, y = `Trips (in thousands)`, fill = `Trips (in thousands)`)) +
ggplot2::geom_col(show.legend = FALSE) +
ggplot2::scale_fill_distiller(palette = "YlOrRd") +
ggplot2::labs(title = "Trip Distance Frequency", subtitle = "Measured in miles") +
ggplot2::scale_x_discrete(guide = ggplot2::guide_axis(n.dodge = 1, angle = 45)) +
ggplot2::theme(
panel.background = ggplot2::element_rect(fill = "#222222", color = NA),
plot.background = ggplot2::element_rect(fill = "#222222", color = NA),
text = ggplot2::element_text(color = "seashell"),
panel.grid = ggplot2::element_blank(),
axis.title.x = ggplot2::element_text(margin = grid::unit(c(5, 5, 5, 5), "mm")),
axis.title.y = ggplot2::element_text(margin = grid::unit(c(5, 5, 5, 5), "mm")),
axis.text.x = ggplot2::element_text(color = "Snow", margin = grid::unit(c(1, 1, 1, 1), "mm")),
axis.text.y = ggplot2::element_text(color = "Snow", margin = grid::unit(c(2, 2, 2, 2), "mm")),
axis.ticks = ggplot2::element_line(color = "LavenderBlush"),
axis.ticks.y = ggplot2::element_blank(),
panel.grid.major.y = ggplot2::element_line(color = "grey30")
)

```
:::
:::

------------------------------------------------------------------------

### Membership Summary {#group_miles_freq}

::: {.d-flex .justify-content-around}
::: {.p-2 .tableScroller style="max-width: 17vw"}
```{r}
#| label: tbl-milesCompare
#| tbl-cap: Miles Group Frequency

dplyr::tbl(dbconn, "db/freqCompare_miles.db") |>
dplyr::arrange(miles) |>
gt::gt(groupname_col = "miles", row_group_as_column = TRUE) |>
gt::tab_header(title = "Distance by Membership", subtitle = "Measured in miles.") |>
gt::fmt_number(decimals = 0, ) |>
gt::cols_label(n = "Trips") |>
gt::tab_options(
table.background.color = 'transparent',
table.font.color = "SeaShell",
table_body.vlines.color = "gray20",
table_body.hlines.color = "gray20",
column_labels.hidden = FALSE
)

# For the miles group frequency membership comparison
milesCompare_tbl <- dplyr::tbl(dbconn, tblPath_fltrd, check_from = FALSE) |>
dplyr::select(member_casual, miles) |>
dplyr::collect() |>
dplyr::mutate(miles = dplyr::case_when(
miles >= 1 ~ round(miles, digits = 0),
miles < 1 ~ round(signif(miles, 3), digits = 1)
)) |>
dplyr::arrange(miles) |>
dplyr::mutate(
miles = forcats::as_factor(miles),
miles = forcats::fct_inorder(miles)
)

miles_compareSummary <- milesCompare_tbl |>
dplyr::select(miles, member_casual) |>
gtsummary::tbl_summary(
by = member_casual, 
label = list(member_casual = "Membership")
)

# miles_compareSummary
```
:::

::: p-2
```{r}
#| label: fig-milesCompare
#| fig-cap: Miles Group Frequency

milesCompare_tbl |>
dplyr::group_by(miles, member_casual) |>
dplyr::summarize(n = dplyr::n()) |>
dplyr::ungroup() |>
ggplot2::ggplot(mapping = ggplot2::aes(x = miles, y = n, fill = n)) +
ggplot2::geom_col(show.legend = FALSE) +
ggplot2::facet_grid(rows = ggplot2::vars(member_casual)) +
ggplot2::scale_fill_distiller(palette = "YlGnBu", name = "Subscriber Status") +
ggplot2::scale_x_discrete(guide = ggplot2::guide_axis(n.dodge = 1, angle = 45)) +
ggplot2::labs(title = "Miles to Membership Frequency", subtitle = "Grouped by sub status") +
ggplot2::theme(
panel.background = ggplot2::element_rect(fill = "#222222", color = NA),
plot.background = ggplot2::element_rect(fill = "#222222", color = NA),
text = ggplot2::element_text(color = "seashell"),
panel.grid = ggplot2::element_blank(),
axis.title.x = ggplot2::element_text(margin = grid::unit(c(5, 5, 5, 5), "mm")),
axis.title.y = ggplot2::element_text(margin = grid::unit(c(5, 5, 5, 5), "mm")),
axis.text.x = ggplot2::element_text(color = "Snow", margin = grid::unit(c(1, 1, 1, 1), "mm")),
axis.text.y = ggplot2::element_text(color = "Snow", margin = grid::unit(c(2, 2, 2, 2), "mm")),
axis.ticks = ggplot2::element_line(color = "LavenderBlush"),
axis.ticks.y = ggplot2::element_blank(),
panel.grid.major.y = ggplot2::element_line(color = "grey30"),
legend.background = ggplot2::element_rect(fill = "#222222")
)
```
:::
:::

### Can distance predict a binary outcome? {#sec-logMiles}

```{r}
#| label: tbl-logMiles


miles_asNums <- dplyr::tbl(dbconn, tblPath_fltrd, check_from = FALSE) |>
dplyr::select(member_casual, miles) |>
dplyr::collect() |>
dplyr::mutate(miles = dplyr::case_when(
miles >= 1 ~ round(miles, digits = 0),
miles < 1 ~ round(signif(miles, 3), digits = 1)
)) |>
dplyr::arrange(miles)

miles_asNums$member_casual <- stringr::str_replace(miles_asNums$member_casual, pattern = "casual", "0")

miles_asNums$member_casual <- stringr::str_replace(miles_asNums$member_casual, pattern = "member", "1")

miles_asNums$member_casual <- miles_asNums$member_casual |> as.integer()

miles_asNums$member_casual <- factor(
miles_asNums$member_casual,
levels = c(0, 1),
labels = c("casual", "member")
)

milesModel <- stats::glm(member_casual ~ miles, data = miles_asNums, family = binomial)

# summary(milesModel)$coefficients

mileStats_tbl <- milesModel |>
gtsummary::tbl_regression(label = list(miles = "Miles", member_casual = "Membership"))


mileStats_tbl |>
gtsummary::as_gt() |>
gt::tab_options(
table.background.color = 'transparent',
table.font.color = "SeaShell",
table_body.vlines.color = "gray20",
table_body.hlines.color = "gray20")


```
:::

## Mph

::: article
::: section
::: {.d-flex .align-content-stretch}
::: {.p-3 .align-self-center}
-   [Totals Summary](#total_mph_freq)
    -   [table](#tbl-mphTotals)
    -   [plot](#fig-mphTotals)
-   [Membership Summary](#group_mph_freq)
    -   [table](#tbl-mphCompare)
    -   [plot](#fig-mphCompare)
-   [Test Association](#sec-logMph)
    -   [table](#tbl-logMph)
:::

::: divBox
:::

::: {.p-1 .align-self-center}
The majority of mph observations fall in between 2-12 mph, as seen in @tbl-mphTotals and @fig-mphTotals.

Member mph observations skew towards a higher mph than casual riders, as seen in @tbl-mphCompare and @fig-mphCompare.

Given, $\beta_1 > 0$, members tend to have a higher estimated average speed for the duration of their trips compared to casuals. @tbl-mphLog
:::
:::
:::


------------------------------------------------------------------------

### Totals Summary {#total_mph_freq}

::: {.d-flex .align-content-stretch}
::: {.p-3 .tableScroller}
```{r}
#| label: tbl-mphTotals
#| tbl-cap: Mph Total Frequency

dplyr::tbl(dbconn, "db/freq_mph.db") |>
dplyr::arrange(mph) |>
gt::gt() |>
gt::tab_header(title = "Mean Speed Frequency", subtitle = "Calculated average speed over the duration of the trip") |>
gt::fmt_number(decimals = 0) |>
gt::cols_label(mph = "Mph", n = "Trips") |>
gt::tab_options(
table.background.color = 'transparent',
table.font.color = "SeaShell",
table_body.vlines.color = "gray20",
table_body.hlines.color = "gray20",
column_labels.hidden = FALSE
)
```
:::

::: p-3
```{r}
#| label: fig-mphTotals
#| fig-cap: Mph Total Frequency


mphTable <- dplyr::tbl(dbconn,
                       "db/freq_mph.db") |>
dplyr::collect()
mphPlot <- mphTable |>
ggplot2::ggplot(mapping = ggplot2::aes(x = mph, y = n, color = n)) +
ggplot2::geom_point(show.legend = FALSE) +
ggplot2::labs(title = "Mean Speed Frequency", subtitle = "Calculated average speed over the duration of the trip", x = "Miles per Hour", y = "Trips") +
ggplot2::scale_color_distiller(palette = "YlOrRd") +
ggplot2::theme(
panel.background = ggplot2::element_rect(fill = "#222222", color = NA),
plot.background = ggplot2::element_rect(fill = "#222222", color = NA),
text = ggplot2::element_text(color = "seashell"),
panel.grid = ggplot2::element_blank(),
axis.title.x = ggplot2::element_text(margin = grid::unit(c(5, 5, 5, 5), "mm")),
axis.title.y = ggplot2::element_text(margin = grid::unit(c(5, 5, 5, 5), "mm")),
axis.text.x = ggplot2::element_text(color = "Snow", margin = grid::unit(c(1, 1, 1, 1), "mm")),
axis.text.y = ggplot2::element_text(color = "Snow", margin = grid::unit(c(2, 2, 2, 2), "mm")),
axis.ticks = ggplot2::element_line(color = "LavenderBlush"),
axis.ticks.y = ggplot2::element_blank(),
panel.grid.major.y = ggplot2::element_line(color = "grey30")
)

mphPlot
```
:::
:::

------------------------------------------------------------------------

### Membership Summary {#group_mph_freq}

::: {.d-flex .align-content-stretch}
::: {.p-3 .tableScroller}
```{r}
#| label: tbl-mphCompare
#| tbl-cap: Mph Group Frequency

dplyr::tbl(dbconn, "db/freqCompare_mph.db") |>
dplyr::arrange(mph, member_casual) |>
dplyr::collect() |>
gt::gt(groupname_col = "mph", row_group_as_column = TRUE) |>
gt::tab_header(title = "Mph - Membership") |>
gt::fmt_number(decimals = 0) |>
gt::cols_label(mph = "Mph", member_casual = "Membership", n = "Trips") |>
gt::tab_options(
table.background.color = 'transparent',
table.font.color = "SeaShell",
table_body.vlines.color = "gray20",
table_body.hlines.color = "gray20",
column_labels.hidden = FALSE)

```
:::

::: p-3
```{r}
#| label: fig-mphCompare
#| fig-cap: Mph Group Frequency

dplyr::tbl(dbconn, "db/freqCompare_mph.db") |>
dplyr::arrange(mph, member_casual) |>
dplyr::collect() |>
ggplot2::ggplot(mapping = ggplot2::aes(x = mph, y = n, color = member_casual)) +
ggplot2::geom_line() +
ggplot2::scale_color_brewer(palette = "Paired", name = NULL) +
ggplot2::labs(title = "Mph to Membership Frequency", subtitle = "Grouped by sub status", x = "Miles per Hour", y = "Trips") +
ggplot2::theme(
panel.background = ggplot2::element_rect(fill = "#222222", color = NA),
plot.background = ggplot2::element_rect(fill = "#222222", color = NA),
text = ggplot2::element_text(color = "seashell"),
panel.grid = ggplot2::element_blank(),
axis.title.x = ggplot2::element_text(margin = grid::unit(c(5, 5, 5, 5), "mm")),
axis.title.y = ggplot2::element_text(margin = grid::unit(c(5, 5, 5, 5), "mm")),
axis.text.x = ggplot2::element_text(color = "Snow", margin = grid::unit(c(1, 1, 1, 1), "mm")),
axis.text.y = ggplot2::element_text(color = "Snow", margin = grid::unit(c(2, 2, 2, 2), "mm")),
axis.ticks = ggplot2::element_line(color = "LavenderBlush"),
axis.ticks.y = ggplot2::element_blank(),
panel.grid.major.y = ggplot2::element_line(color = "grey30"),
legend.background = ggplot2::element_rect(fill = "#222222"))
```
:::
:::

------------------------------------------------------------------------

### Can travel speed predict a binary outcome {#sec-logMph}

```{r}
#| label: tbl-logMph

mph_asNums <- dplyr::tbl(dbconn, tblPath_fltrd, check_from = FALSE) |>
dplyr::select(mph, member_casual) |>
dplyr::mutate(mph = round(mph, digits = 0)) |>
dplyr::arrange(mph) |>
dplyr::collect()


mph_asNums$member_casual <- stringr::str_replace(mph_asNums$member_casual, pattern = "casual", "0")

mph_asNums$member_casual <- stringr::str_replace(mph_asNums$member_casual, pattern = "member", "1")

mph_asNums$member_casual <- mph_asNums$member_casual |> as.integer()

mph_asNums$member_casual <- factor(
mph_asNums$member_casual,
levels = c(0, 1),
labels = c("casual", "member")
)

mphModel <- stats::glm(member_casual ~ mph, data = mph_asNums, family = binomial)

mphStats_tbl <- mphModel |>
gtsummary::tbl_regression(label = list(mph = "Mph", member_casual = "Membership"))

mphStats_tbl |>
gtsummary::as_gt() |>
gt::tab_options(
table.background.color = 'transparent',
table.font.color = "SeaShell",
table_body.vlines.color = "gray20",
table_body.hlines.color = "gray20")

```
:::

## Trip-Times

::: article
::: section
::: {.d-flex .align-content-stretch}
::: {.p-3 .align-self-center}
-   [Totals Summary](#total_tripTime_freq)
    -   [table](#tbl-triptimeTotals)
    -   [plot](#fig-triptimeTotals)
-   [Membership Summary](#group_tripTime_freq)
    -   [table](#tbl-triptimeCompare)
    -   [plot](#fig-triptimeCompare)
-   [Test Association](#sec-logTimes)
    -   [table](#tbl-logTimes)
:::

::: divBox
:::

::: {.p-1 .align-self-center}
The time riders are usually spending on these trips lies between 5 to 15 minutes, as seen in @tbl-triptimeTotals and @fig-triptimeTotals.

The groups as seen in @tbl-triptimeCompare and @fig-triptimeCompare both follow the totals pattern, largely. At the 42 minute mark in the table and plot, the casual riders count becomes greater than for members. Though members ride more frequently, casual riders are more likely to take longer trips.

Given, $\beta_1 < 0$, members are more likely to take shorter trips in terms of how many minutes they ride for on their trips than casuals. @tbl-triptimesLog
:::
:::
:::

::: br
:::

------------------------------------------------------------------------

### Totals Summary {#total_tripTime_freq}

::: {.d-flex}
::: {.p-3 .tableScroller}
```{r}
#| label: tbl-triptimeTotals
#| tbl-cap: Trip-Time Totals

dplyr::tbl(dbconn, "db/freq_tripTime.db") |>
dplyr::collect() |>
dplyr::arrange(trip_time) |>
#head(n = 20) |>
gt::gt() |>
gt::tab_header(title = "Duration Totals") |>
gt::fmt_number(decimals = 0) |>
gt::cols_label(trip_time = "Minutes", n = "Trips") |>
gt::cols_align(columns = "trip_time", align = "center") |>
gt::fmt_number(decimals = 0) |>
gt::tab_options(
table.background.color = 'transparent',
table.font.color = "SeaShell",
table_body.vlines.color = "gray20",
table_body.hlines.color = "gray20",
table.width = gt::pct(25),
column_labels.hidden = FALSE,
row.striping.include_table_body = TRUE
) |>
gt::tab_footnote(
"Total trips taken for the given duration.",
locations =   gt::cells_column_labels(columns = "n")
)

```
:::

::: p-3
```{r}
#| label: fig-triptimeTotals
#| fig-cap: Trip-Time Totals

tripTimeTable <- dplyr::tbl(dbconn, "db/freq_tripTime.db") |>
dplyr::collect()

tripTimePlot <- tripTimeTable |>
ggplot2::ggplot(mapping = ggplot2::aes(x = trip_time, y = n, fill = n)) +
ggplot2::geom_col(show.legend = FALSE) +
ggplot2::labs(title = "Trip Duration Frequency", subtitle = "Tallies the duration of time people rent cycles for") +
ggplot2::scale_fill_distiller(palette = "YlOrRd") +
ggplot2::xlim(NA, 100) +
ggplot2::theme(
panel.background = ggplot2::element_rect(fill = "#222222", color = NA),
plot.background = ggplot2::element_rect(fill = "#222222", color = NA),
text = ggplot2::element_text(color = "seashell"),
panel.grid = ggplot2::element_blank(),
axis.title.x = ggplot2::element_text(margin = grid::unit(c(5, 5, 5, 5), "mm")),
axis.title.y = ggplot2::element_text(margin = grid::unit(c(5, 5, 5, 5), "mm")),
axis.text.x = ggplot2::element_text(color = "Snow", margin = grid::unit(c(1, 1, 1, 1), "mm")),
axis.text.y = ggplot2::element_text(color = "Snow", margin = grid::unit(c(2, 2, 2, 2), "mm")),
axis.ticks = ggplot2::element_line(color = "LavenderBlush"),
axis.ticks.y = ggplot2::element_blank(),
panel.grid.major.y = ggplot2::element_line(color = "grey30")
)

tripTimePlot
```
:::
:::

------------------------------------------------------------------------

### Membership Summary {#group_tripTime_freq}

::: d-flex
::: {.p-3 .tableScroller}
```{r}
#| label: tbl-triptimeCompare
#| tbl-cap: Trip Time Comparison


dplyr::tbl(dbconn, "db/freqCompare_tripTime.db") |>
dplyr::collect() |>
dplyr::arrange(trip_time, member_casual) |>
gt::gt(groupname_col = "trip_time", row_group_as_column = TRUE) |>
gt::tab_header(title = "Durations by Membership", subtitle = "Measured in minutes.") |>
gt::fmt_number(decimals = 0) |>
gt::cols_label(member_casual = "Membership", n = "Trips") |>
gt::tab_options(
table.background.color = 'transparent',
table.font.color = "SeaShell",
column_labels.hidden = FALSE,
row.striping.include_table_body = TRUE
) |>
gt::tab_footnote(footnote = "Trip counts by membership status.",
locations = gt::cells_column_labels("n"))



tripTime_tbl <- dplyr::tbl(dbconn, tblPath_fltrd) |>
dplyr::select(member_casual, trip_time) |>
dplyr::mutate(trip_time = round(trip_time, digits = 0)) |>
dplyr::arrange(trip_time) |>
dplyr::collect() |>
dplyr::mutate(
trip_time = forcats::as_factor(trip_time),
trip_time = forcats::fct_inorder(trip_time)
)


triptime_compareSummary <- tripTime_tbl |>
dplyr::select(trip_time, member_casual) |>
gtsummary::tbl_summary(by = member_casual, label = list(trip_time = "Time (minutes)", member_casual = "Membership")) |>
#gtsummary::add_p() |>
gtsummary::as_gt() |>
gt::tab_options(
table.background.color = 'transparent',
table.font.color = "SeaShell",
table_body.vlines.color = "gray20",
table_body.hlines.color = "gray20")
```
:::

::: p-3
```{r}
#| label: fig-triptimeCompare
#| fig-cap: Trip-Time Group Frequency 

dplyr::tbl(dbconn, "db/freqCompare_tripTime.db") |>
ggplot2::ggplot(mapping = ggplot2::aes(x = trip_time, y = n, color = member_casual)) +
ggplot2::geom_line(show.legend = TRUE) +
ggplot2::xlim(NA, 100) +
ggplot2::scale_color_brewer(palette = "Paired", name = "Subscriber Status") +
ggplot2::labs(title = "Trip-Time to Membership Frequency", subtitle = "Grouped by sub status") +
ggplot2::theme(
panel.background = ggplot2::element_rect(fill = "#222222", color = NA),
plot.background = ggplot2::element_rect(fill = "#222222", color = NA),
text = ggplot2::element_text(color = "seashell"),
panel.grid = ggplot2::element_blank(),
axis.title.x = ggplot2::element_text(margin = grid::unit(c(5, 5, 5, 5), "mm")),
axis.title.y = ggplot2::element_text(margin = grid::unit(c(5, 5, 5, 5), "mm")),
axis.text.x = ggplot2::element_text(color = "Snow", margin = grid::unit(c(1, 1, 1, 1), "mm")),
axis.text.y = ggplot2::element_text(color = "Snow", margin = grid::unit(c(2, 2, 2, 2), "mm")),
axis.ticks = ggplot2::element_line(color = "LavenderBlush"),
axis.ticks.y = ggplot2::element_blank(),
panel.grid.major.y = ggplot2::element_line(color = "grey30"),
legend.background = ggplot2::element_rect(fill = "#222222")
)
```
:::
:::

------------------------------------------------------------------------

### Can trip duration predict a binary outcome? {#sec-logTimes}

```{r}
#| label: tbl-logTimes

# For the trip times comparison
triptime_asNums <- dplyr::tbl(dbconn, tblPath_fltrd) |>
dplyr::select(member_casual, trip_time) |>
dplyr::mutate(trip_time = round(trip_time, digits = 0)) |>
dplyr::arrange(trip_time) |>
dplyr::collect()

triptime_asNums$member_casual <- stringr::str_replace(triptime_asNums$member_casual, pattern = "casual", "0")

triptime_asNums$member_casual <- stringr::str_replace(triptime_asNums$member_casual, pattern = "member", "1")

triptime_asNums$member_casual <- triptime_asNums$member_casual |> as.integer()

triptime_asNums$member_casual <- factor(
triptime_asNums$member_casual,
levels = c(0, 1),
labels = c("casual", "member")
)

triptimeModel <- stats::glm(member_casual ~ trip_time, data = triptime_asNums, family = binomial)


triptimeStats_tbl <- triptimeModel |>
gtsummary::tbl_regression(label = list(trip_time = "Duration", member_casual = "Membership"))

triptimeStats_tbl |>
gtsummary::as_gt() |>
gt::tab_options(
table.background.color = 'transparent',
table.font.color = "SeaShell",
table_body.vlines.color = "gray20",
table_body.hlines.color = "gray20")

```
:::
:::
:::
:::


## Traffic Flow {#sec-epiflow}

::: {.p-3}
For an interesting birds-eye-view of trip behaviors, see @fig-epiflowNetwork. This is called an epiflow diagram. It is interactive, so circles (nodes) and the lines connecting the nodes can be clicked for more information.  There is also a  drop-down window to further explore the data. The top 34 most traveled stations were used for this visual network diagram. The line thickness roughly corresponds with amount of trips taken, so thicker lines means more trips between nodes. [@moragab]

These are the most active stations. Luckily, there might be a way to further explore the typical high traffic station locations and why they are high traffic. @sec-mapview
:::

::: {#offcanvas13 .offcanvas .offcanvas-start tabindex="-1" aria-labelledby="offcanvas" style="width: auto"}
::: offcanvas-header
::: {.h5 .offcanvas-title}
Creating an Epiflow
:::

::: {.btn-close type="button" data-bs-dismiss="offcanvas" ariaLabel="Close"}
:::
:::

::: offcanvas-body
::: flex-code
```{r}
#| label: createFlows dataframe
#| code-summary: First, creates the frequency of trips taken to and from pairs of stations. We are only going to look deeper into the top 50 most traveled pairs.

flowData <- dplyr::tbl(dbconn,
                       tblPath_fltrd) |>
    dplyr::select(start_station_name,
                  end_station_name) |>
    dplyr::group_by(start_station_name,
                    end_station_name) |>
    dplyr::summarize(n = n()) |>
    dplyr::ungroup() |>
    dplyr::arrange(desc(n)) |>
    dplyr::rename("from_station" = start_station_name,
                  "to_station" = end_station_name) |>
    dplyr::collect() |>
    dplyr::slice_head(n = 50)
```

```{r}
#| label: location stats
#| code-summary: Second, we need statistics but also to combine the statistics for every unique station name. 

locationData <- dplyr::tbl(dbconn,
                           tblPath_fltrd) |>
    dplyr::select(start_station_name,
                  end_station_name,
                  started_at,
                  ended_at,
                  trip_time) |>
    dplyr::group_by(start_station_name,
                    end_station_name
                ) |>
    dplyr::mutate("trip_time" = round(trip_time,
                                      digits = 0)) |>
    dplyr::summarize(
        "trip_count" = dplyr::n(),
        "first_date" = min(started_at),
        "last_date" = max(ended_at),
    ) |>
    dplyr::ungroup() |>
    dplyr::rename("from_station" = start_station_name,
                  "to_station" = end_station_name
               ) |>
    dplyr::arrange(desc(trip_count)) |>
    dplyr::collect()



# Need to combine all names to single column and recalculate 
# or retain other stats.
locationData_pivoted <- locationData |>
    tidyr::pivot_longer(cols = 1:2, 
                        values_to = "allNames") |>
    dplyr::group_by(allNames) |>
    dplyr::summarize("trips_toAndfrom" = sum(trip_count),
                     first_date = min(first_date),
                     last_date = max(last_date),
                     ) |>
    dplyr::arrange(trips_toAndfrom)

```

```{r}
#| label: MakeEpiflows
#| code-summary: Third, creates epiflow objects, which take in a pair of dataframes and creates the flows between them. 

# for all the pairs
ef_test <- epiflows::make_epiflows(flows = flowData,
                                   locations = locationData_pivoted,
                                   num_cases = "trips_toAndfrom")
```
:::
:::
:::

::: {#offcanvas14 .offcanvas .offcanvas-end tabindex="-1" aria-labelledby="offcanvas" style="width: auto"}
::: offcanvas-header
::: {.h5 .offcanvas-title}
Tables
:::

::: {.btn-close type="button" data-bs-dismiss="offcanvas" ariaLabel="Close"}
:::
:::

::: offcanvas-body
::: flex-code
```{r}
#| label: summaryFlowData
#| code-summary: First, just a quick view of the flow data table we made earlier.
#| title: Flow Data View

flowData
```

```{r}
#| label: pivotedLocations
#| code-summary: Second, another quick view, but for thethe location data we pivoted earlier.
#| title: Pivoted Location Data

locationData_pivoted |>
    dplyr::arrange(desc(trips_toAndfrom))
```
:::
:::
:::

::: {.article style="color: Black"}
```{r}
#| label: fig-epiflowNetwork
#| fig-cap: EpiFlow Network
#| echo: false

epiflows::vis_epiflows(ef_test)
```
:::

::: {.d-flex .justify-content-center}
::: {.btn-group role="group" aria-label="third"}
::: {.btn .btn-secondary type="button" data-bs-toggle="offcanvas" data-bs-target="#offcanvas13" aria-controls="offcanvas"}
```{=html}
<i class="bi bi-code-slash" style="color: cornflowerblue"></i>
```
:::

::: {.btn .btn-secondary type="button" data-bs-toggle="offcanvas" data-bs-target="#offcanvas14" aria-controls="offcanvas"}
```{=html}
<i class="bi bi-table" style="color: red;"></i>
```
:::
:::
:::

## Checking the Map {#sec-mapview}
:::{.p-3}
This section was made possible thanks to the latitude and longitude coordinates data provided alongside the stations names. Coming from the epiflow diagram, this should help make the data less abstract. The accordion below expands and collapses four *OpenStreet* maps found in the callout section below. These maps were split for viewing logistics. They contain from the epiflow in the section above. These maps are interactive, so the default views are zoomable and movable. The transparent burst buttons enable snappy zooming-in of the station groups.
:::

::: {#offcanvas20 .offcanvas .offcanvas-start tabindex="-1" aria-labelledby="offcanvas" style="width: auto"}
::: offcanvas-header
::: {.h5 .offcanvas-title}
Code for Mapping
:::

::: {.btn-close type="button" data-bs-dismiss="offcanvas" ariaLabel="Close"}
:::
:::

::: offcanvas-body
::: flex-code
```{r}
#| label: mapData
#| code-summary: "Processing 'flowData' created earlier to include geolocation data for mapview plots."

# All distinct stations in one column
names <- flowData |>
    dplyr::select(from_station,
                  to_station) |>
    tidyr::pivot_longer(cols = 1:2,
                        names_to = NULL,
                        values_to = "station_names") |>
    dplyr::distinct()


# The important geo-coordinates corresponding to station names
mapData <- dplyr::tbl(dbconn,
                      tblPath_fltrd,
                      check_from = FALSE) |>
    dplyr::select(start_station_name,
                  start_lat,
                  start_lng,
                  end_station_name,
                  end_lat,
                  end_lng)

# Filter to include all observations that match the station names listed in 'names'. We need the geo-coordinates alongside the names.
mapData1 <- mapData |>
    dplyr::collect() |>
# Filter, but through a vector of conditions.
    dplyr::filter(start_station_name %in% names[[1]],
                  end_station_name %in% names[[1]]) |>
    dplyr::select(start_station_name:start_lng)


# Had to split 'mapData' into two and pivot into a single table.
mapData2 <- mapData |>
    dplyr::collect() |>
    dplyr::filter(start_station_name %in% names[[1]],
                  end_station_name %in% names[[1]]) |>
    dplyr::select(end_station_name:end_lng)

# Nice grouping
stations_groupMap <- dplyr::bind_rows(mapData1, mapData2) |>
dplyr::select(start_station_name, start_lat, start_lng) |>
dplyr::rename("station_names" = start_station_name,
"lat" = start_lat,
"lng" = start_lng) |>
dplyr::distinct() |>
dplyr::group_by(station_names)

# Setting seed for sampling
set.seed(113)

# Taking 10 random samples from each station_name group
sampled_stations <- stations_groupMap |>
    dplyr::slice_sample(n = 10) |>
    tidyr::drop_na()
```

```{r}
#| label: mapColors
#| code-summary: "Creates a map coloring palette excluding grays."

# All of the r-colors
allPalette <- colors()

# The grays are vast so we don't want those watering down the samples.
colorfulPal <- purrr::discard(allPalette, stringr::str_detect(allPalette, "gr(a|e)y"))

# When we sample the colors, 10 should be slightly more than needed.
n_colors <- 10
```

```{r}
#| label: mapViewer
#| code-summary: First, sourcing the script needed to generate the maps and creating the list of vectors used as input. These vectors are the slices of the top most traveled stations.

slicerVector <- list(c(1:9), c(10:18), c(19:27), c(28:34))
source("mapViewer.R")
```

```{r}
#| file: "mapViewer.R"
#| eval: false
#| code-summary: "The script used to generate the maps."
#| label: mapViewerScript
```
:::
:::
:::

::: {#accordionParent .accordion .mt-3 .mb-3}
::: accordion-item
::: {#headingOne .accordion-header}
::: {.accordion-button .collapsed type="button" data-bs-toggle="collapse" data-bs-target="#collapseOne" aria-expanded="true" aria-controls="collapseOne" style="background-color: #bbab9b"}
Benson Ave & Church St ... Ellis Ave & 60th St
:::
:::

::: {#collapseOne .accordion-collapse .collapse aria-labelledby="headingOne" data-bs-parent="#accordionParent"}
::: accordion-body
```{r}
#| label: fig-map1
#| fig-cap: "Benson Ave & Church St - Ellis Ave & 60th St"

set.seed(240)
randomColors <- sample(colorfulPal, n_colors)
mapViewer(slicerVector[[1]])

```
:::
:::
:::

::: accordion-item
::: {#headingTwo .accordion-header}
::: {.accordion-button .collapsed type="button" data-bs-toggle="collapse" data-bs-target="#collapseTwo" aria-expanded="false" aria-controls="collapseTwo" style="background-color: #8b6f47"}
Greenview Ave & Fullteron Ave ... Loomis Ave & Lexington St
:::
:::

::: {#collapseTwo .accordion-collapse .collapse aria-labelledby="headingTwo" data-bs-parent="#accordionParent"}
::: accordion-body
```{r}
#| label: fig-map2
#| echo: false
#| fig-cap: "Greenview Ave & Fullteron Ave - Loomis Ave & Lexington St"

set.seed(241)
randomColors <- sample(colorfulPal, n_colors)
mapViewer(slicerVector[[2]])

```
:::
:::
:::

::: accordion-item
::: {#headingThree .accordion-header}
::: {.accordion-button .collapsed type="button" data-bs-toggle="collapse" data-bs-target="#collapseThree" aria-expanded="false" aria-controls="collapseThree" style="background-color: #587e76"}
Michigan Ave & Oak St ... State St & 33rd St
:::
:::

::: {#collapseThree .accordion-collapse .collapse aria-labelledby="headingThree" data-bs-parent="#accordionParent"}
::: accordion-body
```{r}
#| label: fig-map3
#| echo: false
#| fig-cap: "Michigan Ave & Oak St - State St & 33rd St"

set.seed(242)
randomColors <- sample(colorfulPal, n_colors)
mapViewer(slicerVector[[3]])

```
:::
:::
:::

::: accordion-item
::: {#headingFour .accordion-header}
::: {.accordion-button .collapsed type="button" data-bs-toggle="collapse" data-bs-target="#collapseFour" aria-expanded="false" aria-controls="collapseFour" style="background-color: #4f3222"}
Street Dr & Grand Ave ... Woodlawn Ave & 55th St
:::
:::

::: {#collapseFour .accordion-collapse .collapse aria-labelledby="headingFour" data-bs-parent="#accordionParent"}
::: accordion-body
```{r}
#| label: fig-map4
#| fig-cap: "Street Dr & Grand Ave - Woodlawn Ave & 55th St"

set.seed(243)
randomColors <- sample(colorfulPal, n_colors)
mapViewer(slicerVector[[4]])
```
:::
:::
:::
:::

:::{.p-2}
For example, suppose *University Ave & 57th St* was selected in the epiflow. As it happens this is at the heart of the University of Chicago. So where does the traffic to and from this location usually flow to? Selecting one of the other nodes highlighted with flows directing away from the previous node, is *Kimbark Ave and 53rd St*. This location is seated adjacent to the *Vue 53 Apartments* complex in the map view. 
:::

# Where to Next?

I'm almost to the conclusion, but not quite. I am not finished with this document, yet. I probably will be finished within a week from date of publication listed at the top of the document.

```{r}
#| eval: false
#| include: false

# If you need to drop any tables
source("duckDrops.R")
```
